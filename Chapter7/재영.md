# 📘 07 / 함께 모으기

## 개요
- 마틴 파울러의 **세 가지 상호 연관 관점**
    1) **개념 관점(Conceptual)**: 도메인의 **개념/규칙/관계**를 반영(사용자 시각).
    2) **명세 관점(Specification)**: 객체의 **인터페이스**(**수신 메시지**)에 집중(개발자 외부 시각).
    3) **구현 관점(Implementation)**: **속성/메서드의 내부 구현**(개발자 내부 시각).
- 이 셋은 **개발 순서가 아니라 동일한 클래스를 비추는 서로 다른 각도**다.  
  ⇒ **하나의 클래스** 안에서 **개념·인터페이스·구현**이 조화롭게 드러나야 한다.

---

## 커피 전문점 도메인 (개념 → 관계 → 타입)
1) 개발 전 도메인 구상 (**객체 식별**):
    - 커피 전문점 안에는 메뉴판이 존재함.
   - 메뉴판에는 아메리카노, 카푸치노, 카라멜 마키아또, 에스프레소 네 가지 커피 메뉴가 적혀있음.

     → 메뉴판과, 각각의 메뉴 항목들 역시 모두 개별 객체임.

   - 즉, 메뉴판은 네 개의 메뉴 항목 객체를 포함하는 객체로 볼 수 있음.
   - 손님 객체는 메뉴판 객체 안에 적힌 메뉴 항목 객체들 중, 자신이 원하는 항목 객체 하나를 선택해 바리스타 객체에게 전달함.
   - 바리스타는 자율적으로 커피를 제조하는 객체로 볼 수 있으며, 제조된 커피 역시 객체임.

    ⇒ 즉, 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상임.
2) 객체들 간 관계 살펴보기 (**관계 식별**):
   - 손님은 주문을 위해 메뉴판을 알아야 함.

      → 손님과 메뉴판 사이 관계 존재를 암시

   - 손님은 바리스타에게 주문을 해야 함.

     → 손님과 바리스타 사이에도 관계 존재

   - 바리스타는 커피를 제조함.

     → 커피와 바리스타 사이에도 관계 존재
   - 손님 객체는 ‘손님 타입’, 바리스타 객체는 ‘바리스타 타입’의 인스턴스로 볼 수 있음.
   - 아메리카노, 에스프레소, 카라멜 마키아또, 카푸치노는 모두 ‘커피 타입’의 인스턴스임.
   - 메뉴판 객체는 ‘메뉴판’타입의 인스턴스고, 네 개의 커피 메뉴 항목 객체를 포함할 수 있음.
   - 네 개의 메뉴 항목 객체 역시 모두 동일한 ‘메뉴 항목 타입’의 인스턴스로 모델링할 수 있음.
3) **타입/인스턴스**간 관계 확인: 
    - 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성됨.
    - 서로 하나의 단위로 움직이므로 메뉴 항목 객체가 메뉴판 객체에 **포함**돼있다고 할 수 있음.
      > 타입간의 관계를 나타낼 때, 속이 찬 마름모는 **포함 관계** 또는 **합성 관계**를 나타냄.
      > 
      > 메뉴 항목 좌측 아래의 4라는 숫자는 메뉴판에 포함되는 메뉴 항목이 4개라는 것을 의미함.
    - 손님 타입은 메뉴판을 알고 있어야 주문 가능하므로 두 타입을 **연결**함.
      > 서로 포함 관계는 아니지만 알고있어야 할 경우, 이를 **연관 관계**라고 함.
      >
      > 이 경우 타입들 사이를 단순한 선으로 연결함.
   - 바리스타는 커피를 제조해야 하므로 커피 타입을 알고있어야 함. 이 역시 연관 관계임.

⇒ 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 **도메인 모델**이라고 함.

(즉, 도메인 개념·관계를 단순화/추상화해 표현한 모델)

---

## 설계하고 구현하기 (What → Who)
- 이제 도메인 모델을 기반으로 협력을 설계해야 함.

  ⇒ 적절한 객체에게 적절한 책임을 할당하는 것.


- 협력 설계 시 메시지를 먼저 선택하고, 그 후에 적절한 객체를 선택해야 함.

### 현재 설계하고 있는 협력 : 커피 주문
(What : '주문하기' → Who : 손님 객체)
- 첫 번째 **메시지**는 ‘커피를 주문하라’일 것임.

  → 메시지 위에 붙은 화살표는 메시지에 담아 전달될 인자를 의미

  → 이때 ‘메뉴 이름’ 인자를 함께 전송함.

- 해당 메시지를 수신할 **객체**는 손님일 것임.
    - 손님 객체는 이제 커피를 주문할 책임을 할당받음.

(What : '메뉴 항목 찾기' → Who : 메뉴판 객체)
- 손님이 할당된 책임을 수행하는 도중 스스로 할 수 없는 일에 대해 요청을 하게됨.
    - 메뉴 항목을 알지 못하므로, ‘메뉴 항목을 찾아라’라는 **메시지**가 등장함.

      → 이 경우, ‘메뉴 이름’ 인자를 함께 전송함.

- 메뉴 항목을 반환할 수 있는 메뉴판 **객체**에게 해당 책임을 할당함.

  → 메뉴판은 이에 대응되는 ‘메뉴 항목’ 인자를 반환해야 함.

(What : '커피 제조' → Who : 바리스타 객체)
- 손님 객체는 전달받은 메뉴 항목을 바탕으로 커피를 주문할 수 있음.
    - 주문을 위해 ‘커피를 제조하라’라는 **메시지**가 필요.

      → 인자로 ‘메뉴 항목’을 전달하고 ‘커피’를 반환받아야 함.

- 커피 제조 메시지는 바리스타 **객체**가 받게 될 것임.

- 바리스타는 커피 제작에 대한 정보를 스스로 알고 있을것임.
    - 커피 제작에 필요한 지식과 기술은 바리스타의 상태와 행위가 될 것.

      → ‘커피’를 만들어 손님에게 반환해줌.


- 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들임.
    - 수신한 메시지가 객체의 인터페이스를 결정함.

⇒ 남은 일은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제해야 함.

### 인터페이스 표기 :

```java
class Customer {  // 손님
    public void order(String menuName) {}
}

class MenuItem {  // 메뉴 항목
}

class Menu {  // 메뉴판
    public MenuItem choose(String name) {}
}

class Barista {  // 바리스타
    public Coffee makeCoffee(MenuItem menuItem) {}
}

class Coffee {  // 커피
    public Coffee(MenuItem menuItem) {}
}
```

### 구현 :

```java
class Customer {  // 손님
    public void order(String menuName, Menu menu, Brista barista) {
        MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
//                    ...
    }
}
/*
    손님은 주문을 위해 메뉴와 바리스타를 알아야 함.
    즉, Menu객체와 Barista객체를 참조해야 함.
    → 두 객체를 order에 인자로 넣음. MeniItem은 Menu에서 찾아옴.
*/
```

```java
class Menu {  // 메뉴판
    private List<MenuItem> items;
    
    public Menu(List<MenuItem> items) {
        this.items = items;
    }

    public MenuItem choose(String name) {
        for(MenuItem each : items) {
            if(each.getName().equals(name)) {
                return each;
            }
        }
        
        return null;
    }
}
/*
    메뉴는 메뉴 항목을 찾아야 함.
    내부적으로 메뉴 항목 List를 포함하고 있음.
    → 메서드를 통해 menuName에 해당하는 MenuItem 반환.
*/
```

```java
class Barista {  // 바리스타
    public Coffee makeCoffee(MenuItem menuItem) {
        Coffee coffee = new Coffee(menuItem);
        return coffee;
    } 
}
/*
    바리스타는 주문으로 전달받은 menuItem을 통해
    해당하는 커피를 제조함.
*/
```

```java
class Coffee {  // 커피
    private String name;
    private int price;

    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}
/*
    커피는 자기 자신을 생성하기 위한 생성자를 제공함.
    이름과 가격을 속성으로 가지고, 해당 정보를 menuItem에 요청을 보내 받아옴.
    이를 생성자 내부에서 각 속성에 저장함.
*/
```

```java
public class MenuItem {  // 메뉴 항목
    private String name;
    private int price;
    
    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
    }
    
    public int cost() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}
/*
    내부적으로 cost()와 getName() 메시지에 응답 가능하도록 메서드를 구현해야 함.
    속성과 생성자를 통해 '메뉴 항목' 본인을 만들고, getter를 통해 제공함.
*/
```

- 인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확히 예측하는 것은 불가능에 가까움.
    - 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하는 것이 좋음.
- 머릿 속에 객체의 협력 구조가 번뜩인다 → 그래도 코드 구현 시작.
- 설계가 제대로 되지 않는다 → 실제 코드를 작성해가면서 협력의 전체 밑그림을 그려봄.

⇒ 테스트-주도 설계로 코드를 구현하는 사람들이 하는 작업(테스트 코드 작성)이 바로 이것임.

## 코드와 세 가지 관점

- 앞서 작성한 코드는 개념 관점, 명세 관점, 구현 관점에서 각기 다른 사항들을 설명해줌.

### 개념 관점에서 바라보기

- 개념 관점은 도메인과 관련된 **클래스**를 바라봄.
- Customer, Menu, MenuItem, Barista, Coffee 클래스를 보면,
    - 커피 전문점 **도메인을 구성하는 중요한 개념과 관계를 반영**함.
- 예를 들어, 커피를 제조하는 과정을 변경해야 한다?
    - 현실 세계에서 커피를 제조하는 사람은 바리스타임.

      → Barista 클래스가 커피를 제조할 것이라고 쉽게 유추 가능.


### 명세 관점에서 바라보기

- 명세 관점은 클래스의 **인터페이스**를 바라봄.
- 공용 인터페이스는 외부 객체가 해당 객체에 접근할 수 있는 유일한 부분임.

  → 수정 시 해당 객체와 협력하는 모든 객체에 영향을 미치므로, 수정이 어려움.

- 최대한 변화에 안정적으로 만들려면 구현과 관련된 세부사항이 드러나지 않아야 함.

### 구현 관점에서 바라보기

- 구현 관점은 클래스의 **내부 구현**을 바라봄.
- 공용 인터페이스가 아닌, 내부 구현으로써 메서드와 속성을 포함함.
    - 외부 객체에게 영향을 미쳐서는 안됨. 즉, **캡슐화**되어야 함.


⇒ 세 가지 관점은 동일한 코드를 바라보는 서로 다른 관점임.

하나의 클래스 안에 세 관점을 모두 포함하면서도, 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러내야 함.