# 3장. 타입과 추상화

---

# 😁 추상화를 통한 복잡성 극복

도시는 거미줄처럼 얽힌 지하철로 숨 쉰다. 우리가 길을 잃지 않는 이유는 ***“정확한 축척의 지도”*** 가 아니라, 목적에 맞게 왜곡된 **노선도** 덕분이다. 노선도는 강의 굽이도, 건물의 모서리도 모두 버리고 ***“어디서 타고, 어디서 갈아타서, 어떻게 가장 빨리 도착하느냐”*** 만 남긴다. 사실 이게 바로 **추상화**다. 현실에서 출발하되, 목적에 불필요한 세부를 잘라내어 복잡함을 이해 가능한 크기로 줄이는 일. 공통점을 모아 단순하게 만들고, 중요하지 않은 디테일은 과감히 지운다. 훌륭한 추상화는 ***“더 정확한 것”*** 이 아니라 ***“더 목적에 맞는 것”*** 이다.

# 👻 객체지향과 추상화

이 감각을 유지한 채, 앨리스와 하트 여왕이 처음 마주치던 정원을 떠올려 보자. 정원사, 병사, 신하, 왕과 왕비, 공주와 왕자… 수많은 등장인물이 쏟아져 나오지만, 앨리스는 마음속에서 그들을 한 번에 묶어 부른다. *“결국 트럼프들일 뿐이야.”* 여기서 앨리스는 차이를 잠시 눈감고 **공통된 외형과 행동**에 초점을 맞춰 *“트럼프”* 라는 개념으로 세상을 단순화한다. 이렇게 공통점을 기준으로 객체들을 묶는 그릇을 `개념(Concept)`이라고 한다.

앨리스는 등장인물 중 **몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있는** 객체만을 **트럼프**라는 개념으로 추상화했다. 트럼프는 이러한 공통점을 **지닌** 객체들을 포괄한다. 개념을 이용하면 객체를 여러 그룹으로 `분류(Classification)`할 수 있다. 앨리스도 정원에 존재하는 객체를 *“트럼프”* 와 *“토끼”* 라는 두 개의 개념으로 나누고, 각 개념에 적합한 객체가 해당 그룹에 포함되도록 분류했다. 이처럼 객체에 어떤 개념을 적용할 수 있을 때, 그 객체를 그 개념의 `인스턴스(Instance)`라고 한다.

> ***“객체란 특정한 개념을 적용할 수 있는 구체적인 사물이며, 개념이 객체에 적용됐을 때 그 객체는 해당 개념의 인스턴스가 된다.”***
>

# 3️⃣ 개념의 3가지 관점

개념을 객체 분류의 장치로 볼 때는 세 가지 관점을 함께 본다.

- **`심볼(Symbol)`**: 개념을 가리키는 이름
- **`내연(Intension)`**: 개념의 완전한 정의(이 정의로 소속 여부를 판단)
- **`외연(Extension)`**: 그 개념에 속하는 모든 객체의 집합

앞서 이야기한 앨리스의 판단을 위의 3가지 관점에 대입해보자.

- `심볼`: 트럼프
- `내연`: 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
- `외연`: 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕

이를 앨리스의 판단에 대입해 보자.

**심볼**은 트럼프, **내연**은 몸이 납작하고 네 모서리에 손발이 달린 등장인물, **외연**은 정원사·병사·신하·왕자와 공주·하객으로 참석한 왕과 왕비·하트 잭·하트 왕과 여왕 등이다. **중요한 것은 개념으로 객체를 분류한다는 사실이다.** 객체지향 세계에서 가장 유명한 이름이 `클래스(Class)`인 것을 떠올리면, **분류**가 왜 핵심인지 직감할 수 있다.

> ***“분류란 객체에 특정한 개념을 적용하는 행위다. 적용을 결정하는 순간, 그 객체는 해당 집합의 멤버가 된다.”***
>

# 🐚 타입

프로그래밍으로 건너오면 이 개념은 `타입(Type)`이라는 이름으로 바뀐다. **근본적으로 타입은 개념과 동일하다.** 다만 컴퓨터 내부에서는 조금 더 기계적인 얼굴을 띤다. 타입의 역할은 단순하다. **데이터가 어떻게 쓰여야 하는지 규칙을 부여**해, 비트 덩어리의 혼란을 막는 것. 핵심 포인트는 두 가지다.

1. **타입은 그 데이터에 *“무슨 연산을 할 수 있느냐”* 로 결정**된다. 숫자는 더하고 빼고, 불리언은 참/거짓으로 논리 연산을 한다.
2. **내부 표현은 감춘다.** 내부 바이트 배열의 모양을 몰라도, 그 타입이 제공하는 연산만 알면 된다.

즉, 타입은 ***“메모리의 모양***” 이 아니라 ***“허용된 행동 목록”*** 에 관한 약속이다. 요약하면, **데이터 타입은 메모리 안의 데이터를 분류하는 메타데이터**이며, 그 분류는 곧 해당 데이터에 **어떤 연산이 허용되는지**를 결정한다.

# 🎭 객체와 타입 간의 연관성

이제 **객체**로 시선을 돌리자. 객체는 시간에 따라 변하는 **상태**를 갖고, 그 상태를 바꾸는 **행동**으로 협력에 참여한다. 그렇다면 객체의 타입은 무엇으로 정해질까? 앞서 본 원리를 그대로 가져오면 답은 뚜렷하다. **객체의 타입을 결정하는 것은 내부 데이터가 아니라 수행하는 행동**이다. 동일한 메시지를 받아 **같은 책임**을 수행할 수 있다면, 내부 표현이 달라도 같은 타입으로 묶인다.

- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 **객체가 수행하는 행동**이다.
- 객체의 내부 표현은 외부로부터 **캡슐화**된다. 행동을 가장 효과적으로 수행할 수 있다면 내부 표현 방식은 자유롭다.

# 🎯 행동이 우선

결론적으로 **객체의 타입을 결정하는 것은 행동뿐이다.** 데이터는 타입을 결정하지 않는다. 따라서 **같은 타입**에 속한 객체들은 **동일한 메시지**를 수신하고 처리할 수 있지만, `처리 방식(내부 구현)`은 서로 다를 수 있다. 이것이 곧 **다형성**이다. 외부에서 보면 같은 타입(같은 약속)을 지키되, 내부에서 각자 다른 방법으로 응답한다.

이때 데이터는 어디에 있어야 할까? **행동 뒤에 숨는다.** 외부는 ***“무엇을 해달라”*** 는 메시지만 보낼 수 있고, ***“어떻게 할지”*** 는 수신한 객체가 **자율적으로** 결정한다. 이것이 **캡슐화**이며, 느슨한 결합과 대체 가능성을 만들어낸다. 이 흐름을 실제 설계 절차로 옮긴 것이 `책임-주도 설계(RDD)`다. 먼저 협력의 문맥에서 `행동(책임)`을 정하고, 그 행동을 수행하는 데 필요한 `정보(상태)`를 그다음에 도출한다. 한마디로, **행동이 상태를 결정**한다.

결국 앨리스가 정원의 인물들을 **트럼프**로 묶을 수 있었던 이유도, 그들이 **동일한 방식으로 행동**했기 때문이다. **객체를 결정하는 것은 행동이고, 데이터는 그 행동을 따를 뿐**이다. 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다

# 🕸️ 타입의 계층

정원사, 병사, 신하, 왕자와 공주, 왕과 왕비, 하트 왕과 하트 여왕은 정말 **트럼프**일까? 정확히는 ***“트럼프 인간”*** 으로 보는 편이 맞다. 종이 카드와 닮았지만 **걸어 다닌다**는 점에서 **행동이 더 풍부**하기 때문이다. 타입의 정의를 다시 떠올리면, **공통의 행동**이 타입을 결정한다.

트럼프 카드는 납작 엎드리거나 뒤집힐 수는 있지만 **걷지는 못한다**. 반면 **트럼프 인간**은 트럼프가 할 수 있는 모든 행동을 할 수 있을 뿐만 아니라 **걷는다**. 따라서 트럼프와 트럼프 인간은 **`일반화/특수화(Generalization/Specialization)`** 관계다.

- **판단 기준은 언제나 행동**이다(상태/데이터의 많고 적음이 아님).
- **특수 타입**은 **일반 타입의 모든 행동을 동일하게 수행**하면서 **자기 행동을 추가**로 제공한다.
- 이 행동 기반 포함 관계는 외연(객체 집합)에도 반영된다. **특수 타입의 외연은 일반 타입의 외연 안에 속한다.** 즉, **모든 트럼프 인간은 동시에 트럼프**다.
- 중요한 역관계: 내연(행동 집합)이 풍부해질수록(행동이 많아질수록) 외연(소속 객체의 집합)은 **작아진다**. 일반 타입은 행동이 적어 외연이 크고, 특수 타입은 행동이 많아 외연이 작다.
- 프로그래밍에서는 이를 **`슈퍼타입/서브타입`** 관계라고 하며, 핵심은 **행위적 호환성**(서브타입이 슈퍼타입 자리를 **대체 가능**해야 함, 즉 같은 메시지를 받아 **같은 약속**을 지켜야 함)이다.

## 🛠️ 일반화는 추상화를 위한 도구

추상화의 두 번째 차원은 **중요한 것을 강조하기 위해 불필요한 세부를 제거**하는 것이다. 앨리스는 머릿속에서 **트럼프 인간**의 특수한 능력(걷기)을 지우고, **종이 조각처럼 쉽게 뒤집어진다**는 트럼프의 특성에 집중했다. 하나의 정원에 있던 등장인물들의 **차이점을 배제하고 공통점만 강조**해 **트럼프 인간**으로 분류하고, 다시 **불필요한 특성**을 걷어내 **트럼프**로 일반화했다. 현실의 복잡함을 객체지향 패러다임으로 다룰 때, 우리는 보통 **분류**와 **일반화/특수화**를 함께 적용한다.

# 👔 정적 모델

이제 시간의 축을 잠시 걷어내 보자. 앨리스의 **키**와 **위치**는 순간마다 달라지지만, 설계할 때는 그 모든 변화를 일일이 붙잡을 수 없다. 그래서 두 개의 모델을 함께 쓴다.

- **`동적 모델`**: 실제 객체가 살아 움직이며 메시지를 주고받고 상태가 바뀌는 순간들을 포착한다(스냅샷의 연속; UML의 객체·시퀀스 다이어그램 등).
- **`정적 모델`**: 시간에 독립적으로 ***“이 타입이 가질 수 있는 모든 상태와 모든 행동”*** 을 선언한다(타입/클래스 다이어그램). 정적 모델은 변화라는 시간의 요소를 걷어내고, 객체의 본질을 **타입**이라는 추상화로 고정해 보여준다. 복잡성을 견딜 수 있게 만드는 **설계자의 노선도**다.

여기서 흔한 혼동도 정리하자. **클래스와 타입은 동일하지 않다.** 타입은 객체를 분류하는 **개념**이고, 클래스는 그것을 프로그래밍 언어에서 **구현**하는 여러 메커니즘 중 하나다. 많은 언어가 클래스 기반이라 둘을 쉽게 겹쳐 보지만, 설계의 유연성을 잃지 않으려면 구분이 중요하다. 클래스는 타입의 구현일 뿐 아니라 **코드 재사용**의 수단이기도 하다. 반면, 타입을 나누는 기준은 **오직 행동**이다. 먼저 **어떤 메시지를 주고받고 어떤 책임을 질지**를 결정하고, 그리고 나서 **클래스로 어떻게 구현할지**를 선택한다.

결국 이야기는 처음으로 돌아온다. 지하철 노선도는 목적에 맞게 길 찾기에 필요한 것만 남겼다. 앨리스는 정원의 혼잡함 속에서 ***“트럼프”*** 라는 개념으로 세상을 정리했다. 프로그래밍에서도 우리는 **타입**이라는 추상화를 통해 복잡한 객체의 세계를 다룬다. **행동으로 분류하고**, **데이터는 감추고**, **대체 가능성을 유지**한 채 **협력**을 설계한다. 시간의 파도에 흔들리는 객체의 상태는 동적 모델에서 관찰하고, 타입이라는 정적 모델로 본질을 붙잡는다. 그래서 결론은 늘 같다.

> ***“객체를 결정하는 것은 행동이고, 데이터는 그 행동을 따를 뿐이다.”***
>

### <예시 코드>

목적에 맞는 추상화와 더불어 행동을 중심으로 설계하는 것이 핵심이다. 지하철 길찾기에서 `가장 빠르게 가는 목표`와 `환승을 가장 적게 하는 목표`로 나눠서 생각해보자. 목표에 따라 경로를 계획하라는 동일한 메시지를 보내지만, 다른 행동 전략으로 인해 결과는 달라지는 것이다.

일단 목표는 ***“목적에 맞는 경로를 계획하는 것”*** 이다. 길을 찾는다는 목표를 위해 꼭 필요한 정보만 남기는 것, 즉 추상화를 하는 것이다. 일단 `역(Station) 객체`, `구간(Leg) 객체`, 총 걸린 시간이나 환승을 얼마나 했는지에 대한 정보가 담긴 `객체(Journey)`가 필요할 것이다. 다른 좌표나 역 내부가 어떻게 생겼는지는 목표에 전혀 영향을 미치지 않으므로 배제했다.

```java
package chapter3;

// 역 객체
public class Station {

    private final String name;  // 역 이름이 필요할 것

    public Station(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Station station = (Station) o;
        return name.equals(station.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}
```

```java
package chapter3;

// 구간 객체
public class Leg {

    private final Station start;  // 출발역
    private final Station target;  // 도착역
    private final int time;  // 소요 시간

    public Leg(Station start, Station target, int time) {
        this.start = start;
        this.target = target;
        this.time = time;
    }

    public Station getStartStation() {
        return start;
    }

    public Station getTargetStation() {
        return target;
    }

    public int getTime() {
        return time;
    }

    @Override
    public String toString() {
        return "[출발역: " + start + "역 -> 도착역: " + target + "역], 소요 시간: " + time + "분";
    }
}
```

```java
package chapter3;

import java.util.List;

import static java.util.stream.Collectors.toList;

// 최종 여정 객체
public class Journey {

    private final List<Leg> legs;

    public Journey(List<Leg> legs) {
        this.legs = List.copyOf(legs);
    }

    public List<Leg> getLegs() {
        return legs;
    }

    public int getTotalMinutes() {
        return legs.stream().mapToInt(Leg::getTime).sum();
    }

    public int transfers() {
        return Math.max(0, legs.size() - 1);
    }

    @Override
    public String toString() {
        String path = legs.stream().map(l -> l.getStartStation().getName()).collect(toList()).toString()
                .replace("]", " -> "+legs.get(legs.size()-1).getTargetStation().getName() + "]");
        return path + " | 소요 시간: " + getTotalMinutes() + "분, 환승 횟수: " + transfers() + "회";
    }
}
```

이제 클라이언트가 경로를 계획해달라는 요청 메시지를 보내면, 그 메시지를 수신해서 경로를 계획하는 책임이 필요하다. 그걸 `RoutePlanner`로 설계했다. 그리고 최단 경로나 최소 환승 경로를 탐색을 해야 하는 책임은 `CostPolicy`에 명시했다.

```java
package chapter3;

// 경로를 계획하는 메시지
public interface RoutePlanner {
    Journey plan(Station start, Station target, CostPolicy cost);
}
```

```java
package chapter3;

// 점수를 계산하는 메시지
public interface CostPolicy {
    int score(Journey j);
}
```

행동을 먼저 적으면 자연스럽게 인터페이스의 형태가 나온다. 요청 메시지는 최종 경로를 달라는 것이므로 `RoutePlanner`의 행동(`plan`)으로 인해 타입이 `RoutePlanner`로 결정되고, 정책을 결정하는 메시지는 `CostPolicy`의 행동(`score`)로 타입이 `CostPolicy`로 결정된다. 이처럼 내부가 아니라 행동이 타입을 결정하는 것이다.

이제 각각의 정책에 맞는 구현체를 구현하도록 하자.

```java
package chapter3;

// 최단 시간 경로 정책
public class LeastTimePolicy implements CostPolicy {

    @Override
    public int score(Journey j) {
        return j.getTotalMinutes() * 1000 + j.transfers();
    }
}
```

```java
package chapter3;

// 최소 환승 경로 정책
public class LeastTransferPolicy implements CostPolicy {

    @Override
    public int score(Journey j) {
        return j.transfers() * 1000 + j.getTotalMinutes();
    }
}
```

각각의 정책에 맞게 우선순위를 정하기 위해 **1000**을 곱해줬다. 이렇게 하면 절대적으로 우선순위로 두는 사전식 비교를 안전하게 보장할 수 있다. 이제 예시 경로 구현체를 하나 만들고, `main()` 메서드를 실행해보자.

```java
package chapter3;

import java.util.Comparator;
import java.util.List;

// 예시 경로 구현체
public class ExampleImplements implements RoutePlanner {

    @Override
    public Journey plan(Station start, Station target, CostPolicy cost) {
        List<Journey> journeys = examples(start, target);

        return journeys.stream().min(Comparator.comparingInt(cost::score)).orElseThrow(() -> new IllegalStateException("해당하는 경로가 없습니다..."));
    }

    // A역부터 E역까지의 경로
    private List<Journey> examples(Station A, Station E) {
        Station B = new Station("B");
        Station C = new Station("C");
        Station D = new Station("D");

        // 예시 경로
        Journey leastTime = new Journey(List.of(new Leg(A, B, 10), new Leg(B, C, 10), new Leg(C, E, 5)));
        Journey leastTransfers = new Journey(List.of(new Leg(A, D, 20), new Leg(D, E, 10)));

        return List.of(leastTime, leastTransfers);
    }
}
```

```java
package chapter3;

public class JourneyMain {
    public static void main(String[] args) {

        Station A = new Station("A");
        Station E = new Station("E");

        RoutePlanner planner = new ExampleImplements();  // 예시 경로 구현체

        Journey leastTime = planner.plan(A, E, new LeastTimePolicy());  // 정책 구현체 선택
        Journey leastTransfers = planner.plan(A, E, new LeastTransferPolicy());  // 정책 구현체 선택

        System.out.println("[최단 시간 경로] " + leastTime);
        System.out.println("[최소 환승 경로] " + leastTransfers);
    }
}

/*
[최단 시간 경로] [A, B, C -> E] | 소요 시간: 25분, 환승 횟수: 2회
[최소 환승 경로] [A, D -> E] | 소요 시간: 30분, 환승 횟수: 1회
*/
```

지금까지의 내용을 RDD 흐름으로 다시 보면…

1. 경로를 계획한다는 협력 시나리오를 생각한다.
2. 각각의 행동(책임)을 생각해서 `plan`, `score`, `getTotalMinutes`, `getTransfers`를 만들었다.
3. 각각의 행동을 만들고 나서 `RoutePlanner`, `CostPolicy`, `Journey` 등과 같이 타입이 도출된다.
4. 이제 행동을 위해 구간 시간이나 역 이름과 같이 최소한의 정보, 즉 상태를 채택했다.
5. 마지막으로 구현체를 갈아 끼워 넣을 수 있게 함으로써 다형성을 실현시켰다.