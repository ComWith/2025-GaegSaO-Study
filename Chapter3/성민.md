# 추상화란?

어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 **복잡도를 극복하는 방법**이다.

복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다. [Kramer 2007]

- 첫 번째 차원은 구체적인 사물들 간의 **공통점은 취하고 차이점은 버리는 일반화**를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 **중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거**함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 **복잡성을 이해하기 쉬운 수준으로 단순화**하는 것이라는 점을 기억해야한다.

# 객체지향과 추상화

## 왜 추상화가 필요한가..?

현실 세계는 너무 복잡해서, 있는 그대로를 모두 표현하려 하면 오히려 이해하기 어려워진다.
이들을 전부 따로따로 인식하면 너무 복잡하다.

그래서 우리는 **공통점은 취하고 차이점은 무시하는 방식**으로 단순화한다.

이 과정을 추상화(Abstraction)라고 한다.

## 개념(concept)

**공통점을 기반으로 객체들을 묶는 기준**을 개념(concept)이라고 부른다.
→ 개념은 추상화의 산물이다.

## 분류(classification)

개념을 가지면 객체들을 그룹으로 분류(classification)할 수 있다.

즉, **개념은 객체를 분류하는 기준**이 된다.

## 인스턴스(instance)

객체가 특정 개념 그룹에 속할 때, 우리는 그 객체를 그 개념의 인스턴스(instance)라고 부른다.

- **객체(Object)**: 특정한 개념을 적용할 수 있는 구체적인 사물
- **인스턴스(Instance)**: 개념이 객체에 적용된 결과

즉, **객체는 개념의 인스턴스**로 이해할 수 있다.

## 개념의 세 가지 관점

어떤 객체에 어떤 개념이 적용됐다고 할 때는 그 개념이 부가하는 의미를 만족시킴으로써 다른 객체와 함께 해당 개념의 일원이 됐다는 것을 의미한다.

객체의 분류 장치로서 개념을 이야기할 때는 아래의 세가지 관점을 함께 언급한다.

- **심볼(symbol)**: 개념을 가리키는 간략한 이름이나 명칭.
- **내연(intension)**: 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
- **외연(extension)**: 개념에 속하는 모든 객체의 집합.

**주의!** - 개념이 심볼, 내연, 외연으로 구성돼 있다는 사실보다는 개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요하다.

## 그래서..?

**분류는 객체지향의 가장 중요한 개념 중 하나다.** 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.

따라서, 분류란?

객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

소중한 객체를 안전하고 적절한 장소에 보관할 수 있도록 최대한 직관적으로 분류해야한다.

## 결론은...

**개념은 객체들의 복잡성을 극복하기 위한 추상화 도구다.** 그 개념을 이용하여 **분류하며** 복잡한 세상을 **추상화**한다.

---

# 타입(type)

## 타입은 개념이다.

타입의 정의는 개념의 정의와 완전히 동일하다. 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다.

타입이란?

우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

## 데이터 타입

타입에 관련된 중요한 두 가지 사실

1. **타입은 데이터가 어떻게 사용되느냐에 관한 것이다.**  
ex) 숫자형 데이터가 숫자형인 이유는 데이터를 더하거나 빼거나 곱하거나 나눌 수 있기 때문
2. **타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.**  
ex) 개발자는 메모리 내부에 숫자가 어떤 방식으로 저장되는지를 모르더라도 숫자형 데이터를 사용할 수 있다.

데이터 타입이란?

메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

## 객체와 타입

앞서 데이터 타입에 대해 설명한 이유는 객체지향의 타입 사이에 깊은 연관성이 있기 때문이다. 실제로 객체지향 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다.

### 그럼 객체는 데이터인가..?

**그렇지 않다**. 객체에서 중요한것은 객체의 행동이다. **상태**는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다.

즉, **객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정**하는 것이 객체지향 설계의 핵심이다.

데이터 타입에 관해 언급했던 두 가지 사실은 객체의 타입을 이야기할 때도 적용된다.

1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 **행동**이다.
2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

## 행동이 우선이다.

### 객체 타입의 기준

객체의 타입은 어떤 행동(책임)을 하느냐로 결정된다.

- 같은 타입에 속한다 = 같은 책임을 가진다.
- 따라서 같은 타입의 객체는 **동일한 메시지를 수신**할 수 있다.

### 동일한 타입, 서로 다른 데이터

- 같은 타입에 속한 객체라도 **내부 데이터 표현 방식**은 다를 수 있다.
- 중요한 건 데이터가 아니라 행동(책임)을 수행할 수 있느냐이다.

### 다형성(Polymorphism)의 의미

다형성이란 동일한 요청(메시지)에 대해 서로 다른 방식으로 응답할 수 있는 능력을 말한다.

- 동일한 메시지를 받는다 → 동일한 책임 수행
- 내부 구현(데이터/처리 방식)은 달라질 수 있다 → 응답 방식이 달라짐
- 이 차이가 곧 **다형성**의 본질이다.

아래 예시를 보면 다형성에 대해 더욱 쉽게 다가갈 수 있을 것이다.

```java
interface Shape {
    void draw(); // 동일한 메시지 (책임)
}

class Circle implements Shape {
    public void draw() {
        System.out.println("원을 그린다."); // Circle 방식
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("사각형을 그린다."); // Rectangle 방식
    }
}
```

- `Shape`라는 타입은 “**draw라는 행동**”을 책임진다.
- Circle과 Rectangle은 동일한 메시지(draw)를 수신하지만, 내부 처리 방식은 다르다. → 다형성

그리고 이 과정에서 중요한 사실은 **데이터의 내부 표현 방식이 외부에 드러나지 않는다**는 점이다.

이 원칙을 캡슐화(encapsulation)라고 한다.

### 캡슐화(Encapsulation)의 의미

데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이다.

- 객체는 외부 협력 시 **행동만 제공**한다.
- 내부 데이터는 외부에 드러내지 않고 **행동 뒤로 감춘다.**

## 타입의 목적

### 왜 타입을 사용해야 할까?

- 객체지향은 객체를 지향하는 것이므로 **객체만 다루면 되는 것 아닌가?**
- 하지만 인간의 인지 능력으로는 **시간에 따라 동적으로 변하는 객체의 상태**를 그대로 다루기엔 너무 복잡하다.

### 결론

- 타입은 객체를 **시간과 무관한 정적인 관점**에서 다룰 수 있도록 돕는다.
- 변화하는 상태를 직접 추적하지 않아도 되므로, **상황을 단순화하고 이해하기 쉽게 만든다.**
- 결국 타입은 추상화(Abstraction)이다.

## 따라서..

객체지향 애플리케이션을 설계하고 구현하기 위해서는 **객체 관점의 동적 모델**과 **객체를 추상화한 타입 관점의 정적 모델**을 적절히 혼용해야한다.
