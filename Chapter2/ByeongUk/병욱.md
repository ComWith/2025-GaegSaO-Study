# 👸 이상한 나라의 객체

## 🤔 객체지향과 인지 능력

인간의 인지 방식은 세상을 **독립적이고 식별 가능한 객체**들의 집합으로 바라보는 데서 출발한다. 객체는 물리적일 수도(컵, 문), 개념적일 수도(주문, 결제) 있다. 소프트웨어의 **객체** 역시 이를 닮아 식별자(Identity), 행동(Behavior), 상태(State)를 갖는다.

이상한 나라의 앨리스를 떠올려보자. 앨리스는 상황에 따라 키가 커졌다 작아졌다 한다. 버섯의 한쪽을 먹으면 작아지고, 상자의 케이크를 먹거나 버섯의 반대쪽을 먹으면 커진다. **결국 앨리스의 키를 변화시키는 것은 앨리스의 행동이다.**

- 케이크/버섯을 먹는 행동이 앨리스의 키와 위치라는 상태를 바꾼다.
- 결과는 **이전 상태**와 **행동의 순서**에 의존한다. 문(40cm)을 통과하는지는 “지금 키/위치” 만 알면 된다.

객체란 식별 가능한 개체 또는 사물이다. 구체적일 수도, 추상적일 수도 있다. 객체는 **구별 가능한 식별자**, **특징적인 행동**, **변경 가능한 상태**를 가진다.

그렇다면 **왜 상태가 필요한가?** 많은 행동의 결과는 과거에 어떤 행동들이 있었는지에 의존한다. 그러나 매번 그 과정을 의식하기는 어렵다. 그래서 행동의 과정과 결과를 단순하게 기술하기 위해 **상태**라는 개념을 사용한다. 상태를 이용하면 과거의 모든 이력을 나열하지 않고도 결과를 예측·설명할 수 있다

상태는 프로퍼티와 링크로 구성되어 있다.

- **`프로퍼티(Property)`**: 키/위치처럼 **객체의 상태를 구성하는 특징**(숫자/문자 등 단순 값 포함)
- **`링크(Link)`**: 객체-객체 간 의미 있는 연결(ex 앨리스 ↔ 음료). 링크가 있어야 메시지(요청/응답)를 주고받을 수 있다.

## 📝 상태와 행동

객체의 상태는 저절로 변경되지 않는다. 객체의 자발적 행동으로 상태가 변경되는 것이다. 행동은 자기 상태뿐 아니라 타 객체의 상태까지 바꿀 수 있어 부수 효과(Side Effect)가 생긴다. 예를 들어, 앨리스가 케이크를 먹으면 (1)앨리스의 키가 줄고 (2)케이크의 양이 줄어든다.

## 💊 캡슐화

객체지향의 의사소통 수단은 **메시지** 하나뿐이다.

- `송신자`: “해당 작업을 해줘.” (메시지 전송)
- `수신자`: “이렇게 처리할게.” (메서드 실행)

예를 들어, `drinkBeverage()`라는 메시지를 앨리스에게 전송하면, 앨리스는 내부적으로 자신의 키를 조정하고, 이어 음료에게 `drunken(quantity)` 메시지를 전송할 수 있다. 이때 **송신자는 수신자의 내부 상태 변경을 알지 못하고, 알 필요도 없다.** 이것이 **캡슐화**다. 상태는 감추고, 행동만 공개하는 것이다. 외부에서는 “무엇을 한다” 만 알면 되고, “어떻게 하는가” 는 수신 객체의 자율인 것이다. 메시지를 수신한 객체는 **어떤 메서드로 처리할지 스스로 결정**하며, 그 결과 변경에 강하고, 협력이 단순하며, **대체 가능성**이 높아진다.

상태를 명확한 **행동 집합** 뒤로 캡슐화하면 객체의 **자율성**이 올라가고 협력은 단순·유연해진다. 이것이 상태를 캡슐화해야 하는 이유다.

## 🎏 식별자

**식별 가능성**은 객체를 서로 구별할 수 있는 특정 프로퍼티(= **식별자**)가 객체 안에 존재함을 뜻한다. 모든 객체는 식별자를 가지며, 이를 통해 구별된다. **값과 객체의 가장 큰 차이**는 값은 식별자가 없고, 객체는 식별자가 있다는 점이다.

- **`값(Value Object)`**: 불변 상태, 동등성(Equality)으로 비교(상태가 같으면 같다)한다.
- **`객체(Entity/Reference Object)`**: 가변 상태, 동일성(Identity)으로 비교(식별자가 같으면 같다)한다.

**상태로는 객체의 동일성을 판단할 수 없다.** 시간에 따라 상태가 변하기 때문이다. 어느 순간 두 객체의 상태가 동일해도, 한쪽 상태가 변하면 곧바로 달라진다. 따라서 가변 객체의 동일성을 판단하려면 **상태 변경과 독립적인 식별자**가 필요하다.

> “식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.”

실무에서는 같은 클래스로 만들어도 문맥에 따라 **값처럼(불변·상태 비교)** 쓰거나 **엔티티처럼(식별자 비교)** 쓸 수 있다. 혼란을 줄이기 위해 **참조 객체(`Reference Object`)**, 값 객체(Value Object)라는 용어를 명시적으로 구분해 쓰곤 한다

정리해보자.

- 객체는 상태를 가지며 상태는 변경 가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
    - 행동의 결과는 **상태에 의존**하며, **순서**가 결과에 영향을 준다
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

## 🤖 기계로서의 객체

일반적으로 객체의 상태를 조회하는 작업을 쿼리(Query)라고 하고 객체의 상태를 변경하는 작업을 명령(Command)이라고 한다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.

가령, 내부를 볼 수 없는 기계 덩어리 하나가 있다고 해보자.

- **사각 버튼 = 명령(Command)**: 상태 변경 (“음료를 마시다”, “문을 통과하다”)
- **원형 버튼 = 쿼리(Query)**: 상태 조회 (“키?”, “위치?”)

이처럼 사용자가 객체 기계의 버튼을 눌러 상태를 변경하거나 상태 조회를 요청하는 것은 객체의 행동을 유발하기 위해 메시지를 전송하는 것과 유사하다. 버튼을 누르는 것은 기계의 사용자지만 눌린 버튼에 따라 어떤 방식으로 동작할지는 기계 스스로 결정한다. 그리고 명령과 쿼리는 객체가 외부에 제공하는 행동이라는 점을 주목해야 한다. 다른 방법을 통해서는 기계를 사용할 수 없다는 것이다. 이것은 **객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동 뿐**이라는 점을 강조한다. 즉, 사용자는 객체가 제공하는 명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.

객체 기계가 제공하는 버튼을 통해서만 상태에 접근할 수 있다는 점은 객체의 캡슐화를 강조한다. 기계 이야기를 이용하면 객체의 식별자 역시 효과적으로 설명 가능하다. 똑같은 2개의 객체 기계가 있다고 가정해보자. 두 기계는 모두 디스플레이 창에 130이라는 숫자를 표시하고 있다. 두 기계는 외부에 동일한 행동을 제공하고 현재의 시점에서 상태 역시 동일하다. 하지만 두 기계를 보는 모든 사람들은 상태가 동일하더라도 두 기계를 구분된 별개의 객체로 인식한다. 이것은 **객체가 상태와 무관하게 구분 가능한 식별자를 가진다**는 것을 의미한다.

## ⚙ 행동이 상태를 결정

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 미친다. 그 이유는 아래와 같다.

- `캡슐화 약화`: 상태가 공개 인터페이스로 새어 나올 가능성↑
- `협력 부재`: 협력 맥락에서 분리된 고립된 객체가 된다
- `재사용성 저하`: 다양한 협력에 참여하기 어려워진다

그래서 이렇게 하도록 하자.

1. **협력 시나리오**를 먼저 그린다.
2. 각 협력 지점에서 필요한 행동(책임)을 정의한다.
3. 그 행동을 수행하려면 어떤 정보(상태)가 필요한지 역으로 도출한다.

협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다. 책임-주도 설계(Responsibility-Driven Design, RDD)는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.

반드시 기억하자. “행동이 상태를 결정한다.”

## 👥 은유와 객체

객체지향은 **현실의 단순 모방**이 아니다. 현실에서 수동적인 존재도 소프트웨어에서는 **능동적인 객체**로 재구성된다(= **의인화, Anthropomorphism**).

현실 개념을 은유(Metaphor)로 끌어와 소프트웨어에 대응시키면, 우리가 떠올리는 모습과 실제 소프트웨어 표현 사이의 **표현적/의미적 차이**를 줄일 수 있다. 그래서 도메인에서 쓰는 **진짜 이름**을 클래스/메시지에 사용하라고 권한다. 이해와 예측 가능성, 유지보수성이 좋아진다.

### <예시 코드>

값 객체는 불변이고, 동등성으로 비교해야 한다. 간단하게 앨리스의 키에 대해서만 구현해보자. 앨리스와 음료는 상태가 변화하는 객체이므로 가변으로 설계하고, 키는 불변 객체로 설계해야 한다. 현재 바뀌는 건 `Alice`라는 엔티티의 `height` 프로퍼티다. 시간이 지남에 따라 다른 `Height` 값으로 교체되는 것이다. 한 번 만들어진 `Height` 인스턴스 안에 있는 값은 바뀌지 않고, 필요할 때 새 인스턴스를 만들어 반환하는 방식이다. 쉽게 말해, 사람의 키는 변하지만, 각 순간을 나타내는 키는 마치 캡쳐를 한 것처럼 변하지 않는 값이다.

```java
package chapter2;

// 앨리스의 키 (불변 + 동등성으로 비교)
public class Height {

    private final int height;

    private Height(int height) {
        if (height < 0) throw new IllegalArgumentException("키는 반드시 양수여야 합니다.");
        this.height = height;
    }

    public static Height ofHeight(int height) {
        return new Height(height);
    }

    public int getHeight() {
        return height;
    }

    public Height plus(int x) {
        return new Height(height + x);
    }

    public Height minus(int x) {
        return new Height(height - x);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        return height == ((Height) o).height;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(height);
    }

    @Override
    public String toString() {
        return height + "cm";
    }

}
```

```java
package chapter2;

import java.util.Objects;
import java.util.UUID;

// 앨리스 객체 (가변 + 식별자 기반으로 동등성 비교)
public class Alice {

    private final UUID id;  // 식별자 - 동일성 판단
    private Height height;

    public Alice(Height height) {
        this.id = UUID.randomUUID();
        this.height = Objects.requireNonNull(height);
    }

    // 쿼리 (상태 조회)
    public Height getHeight() {
        return height;
    }

    // 명령 (상태 변경 - Side Effect 발생)
    public void drink(Beverage potion, int ml) {
        Objects.requireNonNull(potion);
        if (ml <= 0) throw new IllegalArgumentException("음료를 섭취하여야 합니다...");

        // 협력(메시지 전송), 다른 객체의 상태 변경은 그 객체가 알아서 판단
        potion.consume(ml);

        // 자신의 상태 변경 (예를 들어, 2ml 섭취 시 1cm 감소한다고 가정하자)
        this.height = this.height.minus(ml / 2);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Alice)) return false;
        return id.equals(((Alice) o).id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }

    @Override
    public String toString() {
        return "Alice 객체 [식별자 값: " + id + ", 키: " + height + "cm]";
    }
}
```

```java
package chapter2;

import java.util.UUID;

// 음료 객체 (가변 + 식별자 기반으로 동등성 비교)
public class Beverage {

    private final UUID id;  // 엔티티 식별자
    private int remainingPotion;  // 가변 상태 (외부 직접 수정 불가)

    public Beverage(int initialPotion) {
        if (initialPotion < 0) throw new IllegalArgumentException("초기값은 반드시 0 이상이어야 합니다...");
        this.id = UUID.randomUUID();
        this.remainingPotion = initialPotion;
    }

    // 명령 (상태 변경 - Side Effect 발생)
    public void consume(int ml) {
        if (ml <= 0) throw new IllegalArgumentException("섭취량은 양수여야 합니다...");
        if (ml > remainingPotion) throw new IllegalArgumentException("음료가 바닥나기 직전입니다!");
        this.remainingPotion -= ml;  // 자신의 상태는 자신이 바꿈(자율성, 캡슐화)
    }

    // 쿼리 (상태 조회)
    public int remainingPotion() {
        return this.remainingPotion;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Beverage)) return false;
        return id.equals(((Beverage) o).id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }

    @Override
    public String toString() {
        return "Beverage 객체 [식별자 값: " + id + ", 남은 양: " + remainingPotion + "ml]";
    }
}
```

`Height` 객체를 불변으로 설계하는 이유는, 같은 `Height` 인스턴스를 다른 두 객체가 공유해도 한쪽 변경이 다른 쪽에 번지지 않기 때문이다. 가변으로 설계할 경우, 한쪽 객체에서만 키를 변경하고 싶어서 변경했는데 다른 객체에서도 키가 변경되는 참사가 일어나는 것이다.

그럼 계속해서 새로운 인스턴스를 만드는 방식이면 메모리에 무리가 가지 않을까? 다행히도, 더 이상 참조되지 않는 인스턴스의 경우 GC의 대상이 된다. 현대 JVM은 탈출 분석(`Escape Analysis`)을 통해 새로 만든 값이 메서드 밖으로 탈출하지 않으면 JIT가 실제 힙 할당을 없애고 레지스터나 스택에 뿌려 놓기도 한다. 위 코드에서 `Height`는 필드로 저장되고 있기 때문에 대체가 어렵지만, 중간 계산에서 잠깐 쓰는 값들은 아예 할당 자체가 사라진다.

이제 `main()` 메서드에서 결과를 출력해보도록 하자.

```java
package chapter2;

public class DrinkBeverageMain {
    public static void main(String[] args) {

        // (값 객체) 상태 비교를 통해 동등성 판단
        Height h1 = Height.ofHeight(130);
        Height h2 = Height.ofHeight(130);
        System.out.println("값 객체(키)는 동등한가? " + h1.equals(h2));

        // (엔티티) 가변적이기 때문에 식별자로 동일성 판단
        Alice alice1 = new Alice(h1);
        Alice alice2 = new Alice(Height.ofHeight(130));
        System.out.println("앨리스 객체는 동일한가? " + alice1.equals(alice2));

        Beverage potion = new Beverage(50);

        // 쿼리 (상태 조회)
        System.out.println("앨리스의 키: " + alice1.getHeight() + ", 남은 음료의 양: " + potion.remainingPotion() + "ml");

        // 명령 (상태 변경)
        alice1.drink(potion, 20);
        System.out.println("음료를 마신 후, 앨리스의 키: " + alice1.getHeight() + ", 남은 음료의 양: " + potion.remainingPotion() + "ml");
    }
}

/*
값 객체(키)는 동등한가? true
앨리스 객체는 동일한가? false
앨리스의 키: 130cm, 남은 음료의 양: 50ml
음료를 마신 후, 앨리스의 키: 120cm, 남은 음료의 양: 30ml
*/
```

보다시피 값 객체는 동일한 상태면 같은 값으로 보고, 엔티티는 서로 다른 식별자를 가지고 있기 때문에 다른 엔티티로 보고 있다. 한 번의 명령(`alice1.drink(potion, 20)`)으로 두 객체(`Height`, `Beverage`)의 상태가 함께 변화한 것을 볼 수 있다. `drink()` 내부에서 `potion.consume(20)`이 호출됨으로써 메시지가 전송되고 협력이 일어나는 것이다. 이처럼 상태는 메서드로만 바뀌고, 외부에서 필드를 직접 수정하지 않고, 각 객체가 자기 상태를 스스로 변경하고 있다.

항상 명심하자. ***“행동이 상태를 결정한다!”***

위의 예제를 봐도 먼저 `drink()` 라는 행동이 정해지고, 그 행동을 위해 `height`, `remainingPotion` 같은 상태가 도입되고 변경되는 것이다.