# 협력

**협력**은 한 사람이 다른 사람에게 도움을 **요청**할 때 시작된다. 이 과정 속에서 요청과 응답의 연쇄적인 흐름이 발생한다.

결국 어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 **필요한 지식과 행동 방식을 가지고 있기 때문**이다. 

**→ 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.**

# 책임

어떤 객체가 어떤 요청에 대해 응답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 **책임**을 가진다고 말한다.

결국 **어떤 대상에 대한 요청**은 그 대상이 **요청을 처리할 책임이 있음**을 암시한다.

## 책임의 분류

객체의 책임은 ‘**객체가 무엇을 알고 있는가(knowing)**’와 ‘**무엇을 할 수 있는가(doing)**’로 구성된다.

크레이그 라만은 이러한 분류 체계에 따라 객체의 책임을 크게 ‘**아는 것**’과 ‘**하는 것**’의 두 가지 범주로 자세히 분류하고 있다.

- **하는 것(doing)**
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
- **아는 것(knowing)**
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

예시를 이용하여 ‘하는 것’과 ‘아는 것’ 이 두 가지 범주의 책임을 발견할 수 있다.

책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다. 

따라서 책임은 객체의 공용 인터페이스(public interface)를 구성한다. → 나중에 캡슐화로 이어진다.

## 책임과 메시지

한 객체가 다른 객체에게 전송한 요청은 그 요청을 수신한 객체의 책임이 수행되게 한다. 이처럼 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 '**메시지 전송(message-send)**'이라고 한다. 따라서 두 객체 간의 협력은 **메시지**를 통해 이뤄진다.

### 💡 주의할 점

- **메시지(message)**: 외부 객체가 다른 객체에게 보내는 요청의 형태 → “무엇을 해달라” (외부 인터페이스 관점)
- **책임(responsibility)**: 그 요청을 받은 객체가 수행해야 하는 의무 → “어떻게 처리할지” (내부 구현 관점)
- **메시지와 책임은 1:1로 대응되지 않는다.**
→ 하나의 책임이 여러 메시지를 통해 드러날 수도 있다.

## 예시

```java
// 왕 객체
public class King {
    private Hatter hatter; // 아는 것: 모자 장수를 알고 있음

    public King(Hatter hatter) {
        this.hatter = hatter;
    }

    // 하는 것: 재판을 열어서 증언을 요청
    public void holdTrial() {
        System.out.println("왕: 모자 장수에게 증언을 명령한다!");

        // 메시지 전송: "증언하라"
        hatter.testify();
    }
}
```

```java
// 모자 장수 객체
public class Hatter {
    private String name = "모자 장수"; // 아는 것: 자신의 이름

    // 공용 인터페이스 (public method)
    public void testify() {   // 하는 것 → 외부 요청을 받아 행동 수행
        System.out.println(name + ": 네, 사실을 증언하겠습니다!");
        provideEvidence();
    }

    // 내부 구현 (캡슐화, 외부에 직접 공개하지 않음)
    private void provideEvidence() {   // 책임 수행 방식
        System.out.println("모자 장수: 제가 본 것은...");
    }
}
```

```java
// 실행 예시
public class Court {
    public static void main(String[] args) {
        Hatter hatter = new Hatter();
        King king = new King(hatter);

        king.holdTrial(); // 왕이 메시지 전송 → 모자 장수가 책임 수행
    }
}
```

# 역할

어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.

협력 안에서 **역할**은 “**이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다.**”라는 것과 같다.

*그럼 어떤 객체나 대체할 수 있나..?*

아니다. 역할을 대체할 수 있는 객체는 **동일한 메시지를 이해할 수 있는 객체로 한정**된다.

결국 동일한 역할을 수행할 수 있다는 것은 **해당 객체들이 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 것**을 의미히나다. → 이것이 매우 중요한 개념이다.

*요약해서 역할은..?*

1. 유사한 **협력을 추상화**해서 **인지 과부하를 줄일 수 있다.**
2. 다양한 객체들이 동일한 협력에 참여할 수 있기 때문에 **재사용성이 높아진다.**
3. 객체지향 설계의 단순성(simplicity), 유연성(flexibility), 재사용성(reusability)을 뒷받침하는 핵심 개념이다.

## 대체 가능성

역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다. 따라서 본질적으로 역할은 다른 객체에 의해 대체 가능함을 의미한다.

1. 객체가 역할을 대체하기 위해서는 **행동이 호환돼야 한다는 점**이다.
2. 객체가 역할에 **주어진 책임 이외에 다른 책임을 수행**할 수도 있다.

결국 객체는 **역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다**. 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 일반화/특수화 관계가 성립하는 것이다.

## 흔한 선입견

1. 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견을 가지고 있다.

→ 객체가 일부 데이터를 포함하는 것은 사실이나… 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다. 따라서 **실제로 중요한 것은 객체의 행동, 즉 책임이다.**

1. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다.

→ 중요한 것은 **정적인 클래스가 아니라 협력에 참여하는 동적인 객체이다.** 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘이다.

## 협력을 따라 흐르는 객체의 책임

<aside>

1. **협력 설계부터 시작한다**
    - 올바른 객체를 만들려면, 먼저 객체들이 어떻게 서로 협력할지(요청과 응답의 흐름)를 설계해야 한다.
    - → "누가 누구에게 무엇을 요청하고, 어떻게 응답하는가?"
2. **협력 안에서 책임을 찾는다**
    - 협력 과정에서 각 객체가 맡아야 할 책임이 드러난다.
    - → "이 객체는 어떤 역할을 맡아야 하는가?"
3. **책임 = 외부에 제공할 행동**
    - 책임이 정해지면, 그 객체는 외부에 “행동(메서드)”으로 그 책임을 드러낸다.
    - → "책임이 곧 행동으로 표현된다."
4. **행동 → 필요한 데이터가 결정된다**
    - 행동을 수행하다 보면 그 행동을 위해 필요한 데이터(필드, 상태)가 무엇인지 정해진다.
    - → "행동이 먼저, 데이터는 나중"
5. **마지막으로 클래스와 데이터 구조를 정의한다**
    - 책임(행동)과 필요한 데이터가 정리되면, 그제야 클래스의 구현을 한다.
    - → "클래스/데이터는 협력과 책임이 결정된 이후에야 등장"
</aside>

따라서 객체지향 설계는 “클래스와 데이터부터”가 아니라, “**협력 → 책임 → 행동 → 데이터 → 클래스**” 흐름으로 가야 한다.

## 객체지향 설계 기법

역할, 책임, 협력의 관점에서 애플리케이션을 설계하는 유용한 세 가지 기법을 살펴보자.

- **책임-주도 설계(Responsibility-Driven Design)** : 

협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.

- **디자인 패턴(Design Pattern)** : 

전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음이다.

- **테스트-주도 개발(Test-Driven Development)** : 

테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완생해가는 방식이다.


### **책임-주도 설계(Responsibility-Driven Design)**

객체지향 설계란 애플리케이션의 기능을 구현하기 위한 **협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정**이다.

객체지향 설계의 핵심은 **올바른 책임을 올바른 객체에게 할당하는 것이다.**

<aside>

협조적이고 성실한 객체 시민들로 구성된 객체지향 시스템을 설계하는 절차는 다음과 같이 요약한다.

1. 시스템이 사용자에게 제공해야하는 기능인 **시스템 책임**을 파악한다.
2. 시스템 책임을 **더 작은 책임**으로 분할한다.
3. 분할된 책임을 수행할 수 있는 **적절한 객체 또는 역할을 찾아 책임을 할당**한다.
4. 객체가 책임을 수행하는 중에 **다른 객체의 도움이 필요한 경우** 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 **두 객체가 협력**하게 한다.
</aside>

### **디자인 패턴(Design Pattern)**

**책임-주도 설계**가 객체의 **역할·책임·협력**을 설계하는 과정이라면, **디자인 패턴**은 그 결과를 **재사용 가능한 템플릿**으로 정리한 것.

가장 유명한 책은 **GOF(Gang of Four)의 『Design Patterns』** 으로, 23개의 패턴을 정리해 객체지향 설계의 표준이 되었다.

<aside>

**디자인 패턴의 의미**

- 공통적으로 활용할 수 있는 **역할·책임·협력의 템플릿**
- 책임-주도 설계의 **결과물**이자, 설계를 빠르게 도와주는 **지름길**
</aside>

### **테스트-주도 개발(Test-Driven Development, TDD)**

- **TDD 개발 순서**
1. **Red (실패하는 테스트 먼저 작성)**
    - 아직 기능이 없으니까 테스트는 반드시 실패해야 함.
    - 이 단계에서 **“어떤 책임(행동)을 객체가 해야 하는가?”** 를 먼저 생각하게 됨.

```java
@Test
void depositIncreasesBalance() {
    BankAccount account = new BankAccount(1000);
    account.deposit(500);
    assertEquals(1500, account.getBalance());
}
```

➡️ 아직 `deposit()` 구현이 없으니 테스트는 실패 (Red).

2. **Green (최소한의 코드로 테스트 통과)**
    - 테스트가 통과할 수 있게 **딱 필요한 만큼만 코드 작성**.

```java
public class BankAccount {
    private int balance;

    public BankAccount(int balance) {
        this.balance = balance;
    }

    // 최소 구현 (딱 테스트를 통과할 만큼만)
    public void deposit(int amount) {
        balance += amount;
    }

    public int getBalance() {
        return balance;
    }
}
```

➡️ 테스트 실행 → 성공 (Green).

3. **Refactor (리팩터링)**
    - 중복된 코드 제거, 변수명 정리, 메서드 추출 등 **코드 품질 개선**.
    - 중요한 건 **동작(테스트 결과)은 그대로 유지**하면서 내부 구현만 개선한다는 점.

이렇게 1. **Red → 2. Green → 3. Refactor** 사이클을 반복하면서 프로그램을 점진적으로 완성해가는 게 TDD의 핵심!

- **책임-주도 설계와의 관계**

  - TDD는 테스트를 먼저 작성하면서, 자연스럽게 **객체에게 어떤 책임을 줄지** 고민하게 만든다.
  - 즉, **책임-주도 설계의 절차를 아주 짧은 시간 단위로 수행**하는 방식이다.

책에서 말하는 것처럼, 설계 단계를 따로 길게 하지 않고, **테스트 코드 작성 과정에서 설계가 동시에 이뤄지는 것**.

- **TDD가 어려운 이유**

  - **다양한 설계 경험**과 **디자인 패턴 지식**이 부족하면, 테스트는 짤 수 있어도 좋은 구조로 발전시키기가 어렵다.
  - 단순히 테스트를 짜고 코드만 통과시키면 설계가 엉망이 되기 쉽다.

그래서 책에서 말하는 게 👉 “설계 경험이 없는 사람은 TDD의 온전한 혜택을 누리기 어렵다”는 것.

- **TDD의 장점**

  - 코드가 항상 테스트로 검증되므로 **안정감**이 높다.
  - 테스트를 먼저 짜면서, **사용자 관점에서 객체의 인터페이스(public interface)를 먼저 고민**하게 된다.
  - 결과적으로 **책임-주도 설계**와 잘 맞아떨어진다.

