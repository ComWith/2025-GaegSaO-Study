# 4장. 역할, 책임, 협력

---

# ✍🏻 문맥이 행동을 결정

인간은 흔히 **이기적이고 합리적**이라고 말하지만, 실제 삶에서는 타인과의 관계 속에서 **자기 이익을 일부 희생하는 비합리적 선택**을 하기도 한다. 이 모순은 인간의 **본질**이 아니라 상황(문맥, *Context*)이 행동을 좌우한다는 사실을 보여 준다. 핵심은 간단하다. **협력이라는 문맥이 행동을 재구성**한다.

객체의 세계도 동일하다. **어떤 협력에 참여하느냐**가 객체에 필요한 행동(책임)을 결정하고, 그 행동이 다시 **상태**를 결정한다. 그러니 개별 객체의 데이터부터 보지 말고 **객체들 사이의 협력**에 초점을 맞추자.

# ⛓️ 협력이란 요청과 응답의 연쇄

협력은 요청(Request)으로 시작해 응답(Response)으로 이어진다. 요청을 받은 쪽은 일을 처리하고, 결과(지식·서비스)로 응답한다. 이 과정은 **여러 요청과 응답이 연쇄**되어 흐름을 만든다.

이상한 나라의 앨리스의 **재판 장면**을 떠올려 보자. 왕, 하얀 토끼, 모자 장수, 앨리스 등 수많은 인물이 등장한다. 이들의 목표는 한 가지, **하트 잭을 재판**하는 것이다.

객체지향 관점에서 재판 장면에 등장하는 모든 등장인물들은 객체다. 왕과 하얀 토끼, 모자 장수라고 불리는 객체들은 하트 잭을 재판하기 위해 서로 협력하고 있다. 앨리스의 이야기에서 왕이 모자 장수로부터 증언을 듣는 과정을 요청과 응답이라는 관점에서 살펴보자.

- 누군가가 왕에게 재판을 요청함으로써 재판이 시작된다.
- 왕이 하얀 토끼에게 증인을 부를 것을 요청한다.
- 왕의 요청을 받은 토끼는 모자 장수에게 증인석으로 입장할 것을 요청한다.
- 모자 장수는 증인석에 입장함으로써 토끼의 요청에 응답한다.
- 모자 장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 응답이기도 하다.
- 이제 왕은 모자 장수에게 증언할 것을 요청한다.
- 모자 장수는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 응답한다.

어떤 인물이 이런 요청을 받아들일 수 있는 이유는, 그에 **응답할 지식과 행동 방식을 보유**하기 때문이다. 그리고 **요청/응답**이 곧 협력에서 각 객체가 수행할 **책임**을 정의한다.

# 🤔 책임: Doing & Knowing

객체지향의 세계에서는 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다. 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시한다. 책임은 객체지향 설계의 가장 중요한 재료다. 객체의 책임은 **`“객체가 무엇을 알고 있는가(Knowing)”`** 와 **`“무엇을 할 수 있는가(Doing)”`** 로 구성된다.

- `하는 것(Doing)`
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것


- `아는 것(Knowing)`
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다. 즉, 책임은 객체의 외부에 재공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다. 따라서 책임은 객체의 `공용 인터페이스(Public Interface)`를 구성한다.

한 가지 주의할 점은 책임과 메시지의 수준이 같지는 않다는 점이다. 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다. 초기 설계에서는 *“누가 어떤 책임을 지고, 누구에게서 어떤 메시지를 받는가”* 만 분명해도 충분하다.

# 🙍🏻‍♂️ 역할

협력의 관점에서 어떤 객체가 어떤 책임의 집합을 수행한다는 것이 무엇을 의미하는지 생각해보자. 어떤 `객체가 수행하는 책임의 집합`은 `객체가 협력 안에서 수행하는 역할`을 암시한다. 역할은 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소다.

모자 장수 대신 요리사와 앨리스가 재판의 증인으로 출석하는 장면을 생각해보자. 이전의 상황과의 차이점은 판사로서 재판을 주관하던 왕이 앨리스가 증인으로 채택된 시점에 여왕에게 자신의 일을 위임했다는 사실이다. 일단 요리사가 증언을 하는 상황에 대한 협력 과정을 그려보자.

- 누군가가 왕에게 재판을 요청함으로써 재판이 시작된다.
- 왕이 하얀 토끼에게 증인을 부를 것을 요청한다.
- 왕의 요청을 받은 토끼는 요리사에게 증인석으로 입장할 것을 요청한다.
- 요리사는 증인석에 입장함으로써 토끼의 요청에 응답한다.
- 요리사의 입장은 연쇄적으로 토끼에 대한 왕의 요청에 대한 응답이기도 하다.
- 이제 왕은 요리사에게 증언할 것을 요청한다.
- 요리사는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 응답한다.

앨리스가 증언을 하는 장면에 이르면 왕은 여왕으로, 증인으로 출석한 모자 장수와 요리사의 자리는 앨리스로 바뀐다. 이 상황에 대한 협력 과정도 나열해보자.

- 누군가가 여왕에게 재판을 요청함으로써 재판이 시작된다.
- 여왕이 하얀 토끼에게 증인을 부를 것을 요청한다.
- 여왕의 요청을 받은 토끼는 앨리스에게 증인석으로 입장할 것을 요청한다.
- 앨리스는 증인석에 입장함으로써 토끼의 요청에 응답한다.
- 앨리스의 입장은 연쇄적으로 토끼에 대한 여왕의 요청에 대한 응답이기도 하다.
- 이제 여왕은 앨리스에게 증언할 것을 요청한다.
- 앨리스는 자신이 알고 있는 내용을 증언함으로써 여왕의 요청에 응답한다.

감이 온다. 재판이 이루어지는 과정이 완벽하게 동일하다. 차이점이라고는 왕 대신 여왕이, 모자 장수 대신 요리사와 앨리스가 협력에 참여하게 된다는 점이다. 같은 재판이라도 **증인**이 모자 장수일 수도, **요리사**일 수도, **앨리스**일 수도 있다. **판사** 역시 **왕**이 맡을 수도, **여왕**이 맡을 수도 있다. 협력의 본질은 변하지 않는다. 달라지는 것은 **그 자리를 누가 맡느냐**뿐이다.

그래서 `판사`와 `증인`이라는 `역할(Role)`을 사용해서 위 협력들을 모두 포괄할 수 있는 하나의 협력으로 추상화하는 것이다.

- 누군가가 판사에게 재판을 요청함으로써 재판이 시작된다.
- 판사이 하얀 토끼에게 증인을 부를 것을 요청한다.
- 판사의 요청을 받은 토끼는 증인에게 증인석으로 입장할 것을 요청한다.
- 증인은 증인석에 입장함으로써 토끼의 요청에 응답한다.
- 증인의 입장은 연쇄적으로 토끼에 대한 판사의 요청에 대한 응답이기도 하다.
- 이제 판사는 증인에게 증언할 것을 요청한다.
- 증인은 자신이 알고 있는 내용을 증언함으로써 판사의 요청에 응답한다.

이처럼 역할은 “**이 자리는 해당 역할을 수행 가능한 어떤 객체로도 대체 가능**”하다는 신호다. 물론 **아무 객체나** 대체 가능한 것은 아니다. **그 역할이 수신할 메시지를 동일하게 이해하고 처리**해야만 대체가 성립한다. 이것이 곧 행위 호환성(behavioral compatibility)이고, *“동일한 역할 → 동일한 책임 수행”* 이라는 결론으로 이어진다.

요약해보자. 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부화를 줄일 수 있다. 또한 다양한 객체들이 협력에 참여할 수 있기 때문에 재사용성이 높아진다. 역할은 객체지향 설계의 `단순성(Simplicity)`, `유연성(Flexibility)`, `재사용성(Reusability)`을 뒷받침하는 핵심 개념이다.

# 🌙 객체의 모양을 결정하는 협력

객체는 **협력에 참여하며 책임을 수행하기 위해 존재**한다. 따라서 중요한 것은 *“어떤 클래스로 구현할까, 데이터는 무엇일까”* 가 아니라, **그 객체가 협력 안에서 어떤 역할/책임을 맡을 것인가**다.

처음에는 전형적인 왕의 모습을 빌려 소프트웨어 객체를 창조하는 것이 합리적이고 적절해 보일지 모르지만 실제로 동작하는 애플리케이션을 구축하기 위해서는 왕이 참여하는 협력을 우선적으로 고려해야 한다. 앨리스의 이야기는 어떤 애플리케이션에 적합한 객체를 설계하기 위해서는 객체를 협력이라는 문맥에서 떼어놓은 채 어떤 데이터가 필요하고 어떤 클래스로 구현해야 하는지를 고민하는 것이 아무런 도움이 되지 않는다고 말하고 있다.

따라서 설계 순서는 아래와 같아야 한다.

1. 협력을 설계한다. 주고 받을 요청과 응답의 흐름을 정하는 것이다.
2. 흐름 속에서 각 객체의 책임을 할당한다. 외부에 제공할 행동을 정의한다는 말이다.
3. 그 행동을 수행하기 위해 필요한 데이터(상태)를 결정한다.
4. 그리고 나서 클래스를 구현하는 것이다.

앨리스의 이야기를 대입해보면, 협력을 구성하는 데 필요한 일련의 책임을 먼저 고안하고 나면 그 책임을 수행하는 데 필요한 객체를 선택하게 된다. 어떤 책임은 왕에게, 어떤 책임은 하얀 토끼에게, 어떤 책임은 모자 장수에게 할당하면서 책임을 각 객체에게 할당해 나간다. 그리고 이렇게 할당된 책임은 왕과 하얀 토끼, 모자 장수라는 객체들이 외부에 제공하게 될 행동을 정의하게 된다. 이제 행동이 결정됐으니 각 객체가 필요로 하는 데이터를 정의할 수 있다. 그리고 이렇게 데이터와 행동이 결정된 후에야 왕과 하얀 토끼, 모자 장수를 구현하는 클래스를 개발할 수 있는 것이다.

# 🔨 객체지향 설계 기법

이제 애플리케이션을 설계하는 유용한 3가지 기법을 알아보자.

- `책임-주도 설계(Responsibility-Driven Design)`: 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.


- `디자인 패턴(Design Pattern)`: 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음이다. 패턴은 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음이다.


- `테스트-주도 개발(Test-Driven Development)`: 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식을 따른다. 핵심은 테스트 작성이 아니라, 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적잡한지를 피드백받는 것이다.



### <예시 코드>

**문맥(협력) → 행동(책임) → 상태 → 구현** 순서로 재판 과정을 간단하게 설계해보도록 하자. 재판이라는 **협력 시나리오** 속에서 `판사, 소환자, 증인`이라는 **역할이** **요청/응답**을 주고받고, 그 과정에서 필요한 **상태(기록)**가 뒤따라 도출되어야 한다.

먼저 역할과 책임을 먼저 정의해보자. 재판에서의 역할은 판사, 소환자, 증인으로 총 3개의 역할이 있다. 각각의 책임은 판사는 평결을 내려야 하는 책임이 있고, 소환자는 증인을 소환해야 할 책임이 있다. 그리고 증인은 당연히 증언을 해야 할 책임이 있는 것이다. 일단 그에 맞게 역할을 설계해보자.

```java
package chapter4;

// 판사 역할
public interface Judge {
    // 재판을 여는 행동
    Verdict holdTrial(Summoner s, Witness w, TrialRecord record);
}

```

```java
package chapter4;

// 증인을 소환하는 역할
public interface Summoner {
    void summon(Witness witness);  // 증인을 소환하는 행동
}

```

```java
package chapter4;

// 증인 역할
public interface Witness {
    boolean enter();  // 증인석에 입장하는 행동
    Statement testify();  // 증언하는 행동
}
```

이제 상태에 대해 생각해볼 타이밍이다. 먼저 판사를 보면, 판결이라는 행동을 해야 한다. 그에 필요한 값은 유죄인지 무죄인지에 대한 정보가 있어야 할 것이다.

```java
package chapter4;

// 판결 엔티티
public class Verdict {

    private final Type type;  // 판결 유형이라는 상태 필요(유죄/무죄)

    private Verdict(Type type) {
        this.type = type;
    }

    public static Verdict of(Type type) {
        return new Verdict(type);
    }

    public Type getType() {
        return type;
    }

    @Override
    public String toString() {
        return type.name();
    }
}
```

```java
package chapter4;

public enum Type {
    GUILTY,
    INNOCENT
}
```

판결 결과 타입은 유죄와 무죄 2가지로만 설정했다. 그리고 재판이 완료되면 재판 결과라는 객체가 필요할 것이다. 재판 기록에는 증언자들이 증언한 내용이라는 상태가 필요하다.

```java
package chapter4;

import java.util.ArrayList;
import java.util.List;

// 재판 기록 엔티티
public class TrialRecord {

    private final List<Statement> statements = new ArrayList<>();

    // 추가 진술이 있을 경우 재판 기록 수정
    public void append(Statement statement) {
        statements.add(statement);
    }

    int count() {
        return statements.size();
    }

    // 특정 증언 내용이 있다면 유죄
    boolean anyMentions(String keyword) {
        return statements.stream().anyMatch(s -> s.getText().contains(keyword));
    }

    @Override
    public String toString() {
        return statements.toString();
    }
}
```

그리고 마지막으로 증언을 하는 행동에 필요한 상태는 당연하겠지만 증언 내용이다. 바로 설계해보자.

```java
package chapter4;

// 증언 엔티티
public class Statement {

    private final String text;  // 증언 내용이라는 상태가 필요

    private Statement(String text) {
        this.text = text;
    }

    public static Statement of(String text) {
        return new Statement(text);
    }

    public String getText() {
        return text;
    }

    @Override
    public String toString() {
        return text;
    }
}
```

이제 상태까지 모두 정의했으니 그걸 바탕으로 클래스를 설계 및 구현해볼 시간이다. 일단 역할에 따른 구현체들을 만들도록 하자. 하얀 토끼, 모자 장수, 앨리스, 왕, 여왕를 설계하는데 모자 장수와 앨리스는 증인, 왕과 여왕는 판사 역할이다.

```java
package chapter4;

// 소환 요청을 하는 하얀 토끼
public class WhiteRabbit implements Summoner {

    @Override
    public void summon(Witness w) {
        System.out.println("하얀 토끼: 증인 출석을 요청드립니다!");
    }
}
```

```java
package chapter4;

// 증언하는 모자 장수
public class Hatter implements Witness {

    private final String feeling;  // 쫄리는 정도

    Hatter(String feeling) {
        this.feeling = feeling;
    }

    @Override
    public boolean enter() {
        return true;  // 일단 무조건 입장한다고 가정
    }

    @Override
    public Statement testify() {
        String content = switch(feeling) {
            case "nervous" -> "누가 훔친 걸(steal) 봤어요...";
            case "calm" -> "아무 것도 못 봤는데요?";
            default -> "저 그때 그곳에 없었습니다.";
        };

        return Statement.of(content);
    }
}
```

```java
package chapter4;

// 증언하는 앨리스
public class Alice implements Witness {

    @Override
    public boolean enter() {
        return true;
    }

    @Override
    public Statement testify() {
        return Statement.of("좀 억울해보이긴 하네요. 근데 진짜 했는지는 모르겠습니다.");
    }
}
```

```java
package chapter4;

// 판사 역할을 수행하는 왕
public class King implements Judge {

    @Override
    public Verdict holdTrial(Summoner s, Witness w, TrialRecord record) {
        s.summon(w);  // 증인 소환
        if (w.enter()) {
            Statement st = w.testify();
            record.append(st);
        }

        // 그냥 간단하게 증언이 있다면 유죄, 없다면 무죄로 설정
        return Verdict.of(record.count() > 0 ? Type.GUILTY : Type.INNOCENT);
    }
}
```

```java
package chapter4;

// 판사 역할을 수행하는 여왕
public class Queen implements Judge {

    @Override
    public Verdict holdTrial(Summoner s, Witness w, TrialRecord record) {
        s.summon(w);  // 증인 소환
        if (w.enter()) {
            Statement st = w.testify();
            record.append(st);
        }

        // 증언에 "훔치다" 라는 키워드가 있어야 유죄로 판단, 그렇지 않으면 무죄
        return Verdict.of(record.anyMentions("steal") ? Type.GUILTY : Type.INNOCENT);
    }
}
```

여기서 캡슐화도 표현하기 위해 모자 장수의 `기분`이라는 내부 상태를 추가했다. 외부에서는 모자 장수의 기분에 대해 알 수도 없고, 알 필요도 없다. 동일한 역할을 수행하는 왕과 여왕에 대해 차이를 두려고 왕은 그냥 증언이 있다면 유죄로 판단하고, 여왕은 *“훔치다”* 라는 키워드가 있어야 유죄로 판단하도록 했다. 이렇게 같은 역할이어도 로직이 다를 수 있다.

이제 `main()` 메서드를 실행해서 결과를 살펴보도록 하자.

```java
package chapter4;

public class JudgeMain {
    public static void main(String[] args) {

        Summoner whiteRabbit = new WhiteRabbit();

        // 협력1: 왕과 모자 장수
        Judge king = new King();
        Witness hatter = new Hatter("nervous");
        TrialRecord trialRecord1 = new TrialRecord();
        Verdict verdict1 = king.holdTrial(whiteRabbit, hatter, trialRecord1);
        System.out.println("증언 내용: " + trialRecord1 + ", 평결: " + verdict1);

        System.out.println();

        // 협력2: 여왕과 앨리스
        Judge queen = new Queen();
        Witness alice = new Alice();
        TrialRecord trialRecord2 = new TrialRecord();
        Verdict verdict2 = queen.holdTrial(whiteRabbit, alice, trialRecord2);
        System.out.println("증언 내용: " + trialRecord2 + ", 평결: " + verdict2);
    }
}

/*
하얀 토끼: 증인 출석을 요청드립니다!
증언 내용: [누가 훔친 걸(steal) 봤어요...], 평결: GUILTY

하얀 토끼: 증인 출석을 요청드립니다!
증언 내용: [좀 억울해보이긴 하네요. 근데 진짜 했는지는 모르겠습니다.], 평결: INNOCENT
*/
```