# 🙏🏻 협력하는 객체들의 공동체

## 🧑‍🧑‍🧒 역할 + 책임 + 협력

***“객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임”*** 이다. 하지만 이는 단지 철학적 비유일 뿐이고, 객체지향의 본질은 현실 세계의 모방이 아니라, 문제 해결을 위해 고객과 사용자를 만족시킬 수 있는 **새로운 세계를 창조**하는 것이다.

객체는 자신의 상태와 행위를 캡슐화(`Encapsulation`)하여 스스로 책임을 수행할 수 있는 자율성(`Autonomous`)을 가진다. 그리고 동일한 요청에 대해 각기 다른 방식으로 응답할 수 있는 능력이 바로 다형성(`Polymorphism`)이다. 객체들은 서로 메시지(`Message`)를 주고받으며 협력(`Collaboration`)하고, 이 협력 속에서 각자는 맡은 **역할**과 그에 따른 **책임**을 수행한다.

커피 가게를 예로 들어보자. 커피 가게에서는 `손님(주문 요청)`, `캐시어(주문 접수)`, `바리스타(커피 제조)`라는 역할이 존재하고, 이들이 조화를 이루며 협력하는 것이다. 이처럼 커피를 주문하고 제조하는 과정을 봐도 **`역할`**, **`책임`**, `협력`이라는 3가지 개념이 어울려 조화를 이루는 것이다.



여기서 말하는 `역할`은 어떤 협력 관계에서 특정 사람이 차지하는 `책임`이나 임무를 말한다. 다시 말해, ***“특정한 역할은 특정한 책임을 의미하는 것이고, 역할이라는 범주 안에 책임이 포함되는 것이다.”***

기억하자. 객체지향에서 가장 중요한 3가지 개념이다. **`역할`**, **`책임`**, **`협력`...**

협력은 하나의 문제를 해결하기 위해 다수의 사람 혹은 역할이 필요하기 때문에 한 사람에 대한 **“요청(`Request`)”** 이 또 다른 사람에 대한 요청을 유발하고 이는 연쇄적이다. 반대로, 요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스를 제공, 즉 **“응답(`Response`)”** 한다. 응답 역시 반대 방향으로 연쇄적이다.

이처럼 협력을 위해 특정한 역할을 맡고 책임을 수행한다는 사실은 몇 가지 중요한 개념을 보여준다.

1. **여러 사람이 동일한 역할을 수행할 수 있다.** 예를 들어, 카운터 직원은 특별한 누군가만 수행할 수 있는 것이 아니다. 그냥 적합해 보이는 사람 중 한 명을 뽑으면 그만이다.
2. **역할은 대체 가능성을 의미한다.** 마찬가지로, 카운터 직원이 여러 명인데 특정 직원에게만 주문을 하지 않아도 된다. 직원 하나가 주문을 받고 있다면, 다른 직원에게 주문을 하면 된다.
3. **책임을 수행하는 방법은 자율적으로 수행할 수 있다.** 같은 커피숍이라도 본인만의 컨셉이 있을 것이고, 커피 제조 방법이 각기 다를 수 있다. 이처럼 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 **“다형성(`Polymorphism`)”** 이라고 한다.
4. **한 사람이 동시에 여러 역할을 수행할 수 있다.** 1인 가게를 생각하면 편하다. 바리스타 자격증을 가지고 있는 사장님이 주문도 받고, 커피도 제조할 수 있다.

# 🔄 객체로의 전환

이제 사람을 객체로, 사람이 요청하는 것을 메시지로, 요청을 받은 사람이 처리하는 방법을 메서드로 말을 바꿔보면 객체지향이라는 세계로 끌고 올 수 있다.

협력은 **역할을 맡은 객체들이 연쇄적인 요청과 응답을 주고받으며 목표를 달성하는 과정**이다. 목표는 작은 책임으로 분할되고, 각 책임은 이를 수행할 수 있는 객체에게 위임된다. 객체는 요청을 받으면 스스로 판단해 응답하거나, 다른 객체에 도움을 요청해 협력을 완성한다. 사람의 협력은 사회적 목적을 이루기 위한 것이지만, 객체의 협력은 **애플리케이션의 기능을 달성하기 위한 것**이다. 이처럼 올바른 객체지향 설계란 **적절한 객체에게 적절한 책임을 할당하는 것**이다.

객체가 가져야 할 2가지 덕목에 대해 알아보자. 객체는 ***“자존감 높은 오픈마인드 친구”*** 와 같다.

1. `충분히 협력적`
    - 다른 객체의 요청에 응답할 수 있고, 필요할 때 도움을 요청할 수도 있어야 한다.
    - 단, 맹목적으로 따르는 것이 아니라 스스로 판단·결정한 후 협력에 참여한다.
2. `충분히 자율적`
    - 상태와 행동을 스스로 관리하며, 내부 문제는 외부가 간섭할 수 없다.
    - 외부에서는 허용된 방법(인터페이스)을 통해서만 접근 가능하다.
    - 즉, **무엇을 하는지는 알 수 있어도, 어떻게 하는지는 알 수 없다**.

객체지향에서 의사소통을 할 수 있는 방법은 단 한 가지만 존재한다. 바로 **“메시지(`Message`)”** 다.객체가 메시지를 수신하면, 그에 대응하는 `메서드(Method)`가 실행되어 응답한다. 커피를 제조하는 구체적인 방법을 메서드라고 생각하면 편하다.

그래서 객체지향은 무엇인가? 정리해보자.

- 객체지향은 **자율적인 객체들이 서로 상호작용하는 공동체**로 보는 패러다임이다
- 자율적인 객체 = `상태(State)`와 `행동(Behavior)`을 함께 가지며, 스스로 자신의 책임을 진다
- 객체는 시스템 행위를 구현하기 위해 서로 협력하고, 협력 속에서 각자 역할과 책임을 수행한다
- 협력 과정은 **메시지 전송과 응답**으로 이루어지며, 메시지를 받은 객체는 어떤 메서드로 처리할지 **자율적으로 결정**한다

그동안 객체지향에서 가장 중요하다고 생각했던 구성요소인 클래스를 객체지향의 중심 개념이라고 말하기엔 다소 무리가 있다. 왜냐하면 클래스만 지나치게 부각되면 객체의 캡슐화를 저해하고, 클래스를 서로 강하게 결합시킨다. 객체지향의 중심은 객체이며, 중요한 것은 클래스 간의 정적인 관계가 아니라 메시지를 주고받는 객체들의 동적인 관계다.

### <예시 코드>

먼저 고객과 캐시어, 바리스타가 서로 협력하는 일련의 과정에 있어서 필요한 개념들을 소프트웨어적으로 모델링하여 도메인 객체(커피, 메뉴, 주문)를 만들었다. 협력에 대한 결과물은 일단 고객에게 건네는 영수증(`Receipt`)이라고 가정하자.

```java
package chapter1;

// 커피
public class Coffee {

    private final String name;  // 커피 이름이라는 상태
    private final int shots;  // 커피에 들어갈 샷이라는 상태

    public Coffee(String name, int shots) {
        this.name = name;
        this.shots = shots;
    }

    /*
    상태에 접근할 수 있는 유일한 방법 (Getter)
     */
    public String getName() {
        return name;
    }

    public int getShots() {
        return shots;
    }

    @Override
    public String toString() {
        return "Coffee [name=" + name + ", shots=" + shots + "]";
    }
}
```

```java
package chapter1;

// 메뉴
public class Menu {

    private final String name;  // 메뉴 이름이라는 상태
    private final int defaultShots;  // 기본 샷이라는 상태

    public Menu(String name, int defaultShots) {
        this.name = name;
        this.defaultShots = defaultShots;
    }

    /*
    상태에 접근할 수 있는 유일한 방법 (Getter)
     */
    public String getName() {
        return name;
    }

    public int getDefaultShots() {
        return defaultShots;
    }
}
```

```java
package chapter1;

// 주문
public class Order {
    
    private final String customerName;  // 고객 이름이라는 상태
    private final Menu menuItem;  // 고객이 주문할 메뉴라는 상태
    private final int extraShots;  // 추가 샷이라는 상태
    
    public Order(String customerName, Menu menuItem, int extraShots) {
        this.customerName = customerName;
        this.menuItem = menuItem;
        this.extraShots = extraShots;
    }
    
    /*
    상태에 접근할 수 있는 유일한 방법 (Getter)
     */
    public String getCustomerName() {
        return customerName;
    }
    
    public Menu getMenuItem() {
        return menuItem;
    }
    
    public int getExtraShots() {
        return extraShots;
    }
}
```

```java
package chapter1;

// 영수증 (협력의 결과물)
public class Receipt {

    private final Order order;
    private final Coffee coffee;
    private final int price;

    public Receipt(Order order, Coffee coffee, int price) {
        this.order = order;
        this.coffee = coffee;
        this.price = price;
    }

    public Order getOrder() {
        return order;
    }

    public Coffee getCoffee() {
        return coffee;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "Receipt [order=" + order + ", coffee=" + coffee + ", price=" + price + "₩]";
    }
}
```

이제 무엇을 해야 하는가(책임)를 규정하는 역할에 대해 구현해보자. 그리고 위에서 봤듯이 역할은 대체 가능하다고 했으니 인터페이스로 설계하는 것이 적절하다.

```java
package chapter1;

// 캐시어 역할 (주문을 받아 결과를 돌려줌)
public interface Cashier {

    Receipt takeOrder(Order order);
}
```

`Cashier`는 고객으로부터 주문을 받아서 특정 바리스타에게 커피 제조를 요청 후, 정산과 함께 영수증을 고객에게 건네는 책임을 맡는다. `takeOrder(order)`는 주문을 처리해달라는 요청이고, `Receipt`는 그에 대한 응답이라고 할 수 있다. 고객은 내부가 어떻게 돌아가는지는 모른 상태로 ***“주문하면 영수증이 온다.”*** 는 계약만 알고 있는 것이다.

```java
package chapter1;

// 바리스타 역할 (커피를 만듦)
public interface Barista {
    
    Coffee makeCoffee(Order order);
}

```

마찬가지로, `Barista`는 주문서를 읽고, 그에 맞는 `Coffee`를 만들어서 반환한다. `makeCoffee(order)`로 는 커피를 만들어 달라는 요청이고, `Coffee`는 그에 대한 응답이다. 여기서 생각해야 할 점은, `Barista`는 자율성을 가진다는 것이다. 같은 주문이라도 구현체마다 레시피(아메리카노, 라떼, 카푸치노 등)가 다를 수 있다(다형성).

추가로, 가격을 계산하는 작업은 책임 분리를 통해 캡슐화 하도록 했다.

```java
package chapter1;

// 가격 정책 (책임 분리를 통해 가격 정책 캡슐화)
public class Pricing {
    
    private Pricing() {}
    
    public static int calculatePrice(Coffee coffee) {
        int basedPrice = 3000;
        int extraFeePerShot = 500;
        
        return basedPrice + (coffee.getShots() - 1) * extraFeePerShot;
    }
}
```

이제 인터페이스를 구현해보도록 하자. 편의를 위해 일단 캐시어 구현체는 1명, 바리스타 구현체는 2명으로 설정했다.

```java
package chapter1;

public class GoodCashier implements Cashier {

    // 어떤 바리스타와 협력할 것인지 캐시어가 결정
    private final Barista barista;

    public GoodCashier(Barista barista) {
        this.barista = barista;
    }

    @Override
    public Receipt takeOrder(Order order) {
        System.out.println("안녕하세요~ " + order.getCustomerName() + "님! 주문 도와드리겠습니다.");
        Coffee coffee = barista.makeCoffee(order);  // 바리스타에게 메시지 전송
        int price = Pricing.calculatePrice(coffee);
        System.out.println("총 " + price + "원입니다. 맛있게 드세요~");
        
        return new Receipt(order, coffee, price);
    }
}
```

```java
package chapter1;

// 아메리카노를 잘하는 바리스타
public class AmericanoBarista implements Barista {
    
    @Override
    public Coffee makeCoffee(Order order) {
        int shots = order.getMenuItem().getDefaultShots() + order.getExtraShots();
        System.out.println("기가 막힌 아메리카노 제조 중...");
        
        return new Coffee(order.getMenuItem().getName(), shots);
    }
}
```

```java
package chapter1;

// 라떼를 잘하는 바리스타
public class LatteBarista implements Barista {

    @Override
    public Coffee makeCoffee(Order order) {
        int shots = order.getMenuItem().getDefaultShots() + order.getExtraShots();
        System.out.println("기가 막힌 카페라떼 제조 중...");

        return new Coffee(order.getMenuItem().getName(), shots);
    }
}
```

이제 이 협력의 시작점, 고객 객체에 대해 설계해보자.

```java
package chapter1;

// 고객
public class Customer {

    private final String name;

    public Customer(String name) {
        this.name = name;
    }

    public Receipt order(Cashier cashier, Menu menuItem, int extraShots) {
        Order order = new Order(name, menuItem, extraShots);  // 주문 생성
        return cashier.takeOrder(order);  // 캐시어로부터 주문에 대한 영수증을 받음
    }
}
```

`Customer`는 주문을 하면 주문 객체가 생성되고, 그 주문(`order`)을 받은 `cashier`는 거기에 맞는 영수증과 멘트를 날려주는 것이다.

```java
package chapter1;

public class CoffeeShopMain {
    public static void main(String[] args) {

        Menu americano = new Menu("아메리카노", 2);
        Menu latte = new Menu("카페라떼", 1);
        Customer alice = new Customer("Alice");
        Customer bob = new Customer("Bob");

        Cashier goodCashier1 = new GoodCashier(new AmericanoBarista());
        Receipt receipt1 = alice.order(goodCashier1, americano, 2);
        System.out.println(receipt1);

        System.out.println();

        Cashier goodCashier2 = new GoodCashier(new LatteBarista());
        Receipt receipt2 = bob.order(goodCashier2, latte, 1);
        System.out.println(receipt2);
    }
}

/*
안녕하세요~ Alice님! 주문 도와드리겠습니다.
기가 막힌 아메리카노 제조 중...
총 4500원입니다. 맛있게 드세요~
Receipt [order=chapter1.Order@6b884d57, coffee=Coffee [name=아메리카노, shots=4], price=4500₩]

안녕하세요~ Bob님! 주문 도와드리겠습니다.
기가 막힌 카페라떼 제조 중...
총 3500원입니다. 맛있게 드세요~
Receipt [order=chapter1.Order@19469ea2, coffee=Coffee [name=카페라떼, shots=2], price=3500₩]
*/
```

또한 1인 가게 사장님처럼 동시에 여러 역할을 가질 수도 있다. 그냥 인터페이스를 여러 개 구현하면 된다.