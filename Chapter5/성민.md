# 메시지와 메서드

## 메시지

**메시지**는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.

하나의 객체는 **메시지**를 전송함으로써 다른 객체에 접근한다.

- 왕이 모자 장수에게 전송하는 메시지를 가리키는 ‘증언하라’라는 부분을 메시지 이름(message name)이라고 한다.
- 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자(argument)를 통해 추가 정보를 제공할 수 있다.  

- **메시지** = 메시지 이름 + 인자
- **메시지 전송** = 수신자 + 메시지 =  수신자 + 메시지 이름 + 인자

## 메서드

메시지를 처리하기 위해 내부적으로 선택하는 방법을 **메서드**라고한다.

동작 흐름

1. 객체가 **메시지를 수신**한다.
2. 해당 메시지를 **처리할 수 있는지 확인**한다.
3. 처리 가능하다면, **어떤 메서드를 실행할지 선택**한다.

메시지는 ‘어떻게’ 수행될 것인지는 명시하지 않는다. 메시지는 단지 오퍼레이션(Operation)을 통해 ‘무엇’이 실행되기를 바라는지만 명시하며, 어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.

- 참고(오퍼레이션이란..?)
    - **오퍼레이션** = 객체가 수행할 수 있는 행위(behavior) 의 선언
    - **메시지** = “이걸 해달라”는 요청 (호출)
    - **메서드** = 요청을 처리하는 구체적인 방법 (구현)

```java
class Calculator {
    // 오퍼레이션 (명세)
    int add(int a, int b);  
    
    // 메서드 (구현)
    int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // 메시지 (호출)
        int result = calc.add(2, 3); // 

        System.out.println(result); // 5
    }
}
```

### 결론은…

- 메시지는 “**무엇**”을 요구하고,
- 메서드는 “**어떻게**”를 결정한다.

### 객체지향 언어 vs 절차적인 언어

**객체지향 언어**에서는

- 객체가 메시지를 수신하면
- 실행 시간(run-time)에 어떤 메서드를 실행할지 스스로 선택한다.

→ 이것이 동적 바인딩(dynamic binding)이며, 절차적인 언어와 구분되는 객체지향의 핵심 특징이다.

**절차적인 언어**에서는

- 어떤 프로시저(Procedure)를 호출하면
- 컴파일 시간(compile-time)에 이미 실행할 코드가 정해진다.
- 즉, 호출 시점에 다른 동작으로 바뀌지 않는다.

즉, 가장 큰 차이점은

- **절차적 언어** = 프로시저 호출 → 정적 바인딩 (컴파일 시 결정)
- **객체지향 언어** = 메시지 전송 → 동적 바인딩 (실행 시점에 결정)
</aside>

- 참고(프로시저란..?)
    - **프로시저**는 특정 기능을 수행하는 코드 블록(함수)을 말한다.
    - C언어를 예시로 보여주겠다.

```c
#include <stdio.h>

// 프로시저 정의
int add(int a, int b) {
    return a + b;
}

int main() {
    // 프로시저 호출
    int result = add(2, 3);  
    printf("%d\n", result);  // 5
}
```

## 다형성(Polymorphism)

### 정의

- **다형성** = 서로 다른 객체가 **동일한 메시지**에 대해 **각기 다른 방식으로 반응**하는 것

즉, **하나의 메시지** ↔ **여러 메서드 구현**

- **메시지**는 “무엇을 해달라”는 요청 (처리 방법 제약 X)
- **메서드**는 그 요청을 처리하는 구체적인 방법

따라서 **같은 메시지라도 객체마다 다른 메서드로 처리할 수 있음**

### 송신자 관점

- 송신자는 **수신자의 종류를 몰라도 됨**
- 수신자가 어떤 메서드를 실행하든, 송신자 입장에서는 **“책임이 수행된다”는 점만 중요**
- 즉, 다형성은 **수신자를 구별하지 않아도 되는 대체 가능성을 제공**

### 효과

- **설계 유연성**: 새로운 객체를 추가해도 송신자 코드 변경 최소화
- **재사용성**: 다양한 객체가 동일한 협력 구조에 참여 가능
- **확장성**: 메시지를 이해할 수 있는 어떤 객체와도 협력 가능

## 송신자와 수신자를 약하게 연결하는 메시지

얼핏 보기에는 모든 것이 다형성의 축복처럼 보이지만 이 모든 것은 다형성을 지탱하는 메시지가 존재하기 때문이다.

**수신자와 송신자는 메시지라는 얇은 끈으로만 이어져 있다.** 메시지를 기반으로 한 두 객체 사이의 이 낮은 결합도가 바로 설계를 유연하고 확장 가능하며 재사용 가능하게 만드는 비결이다.

# 메시지를 따라라

## 책임-주도 설계 다시 살펴보기

책임-주도 설계는 **시스템이 수행해야 할 기능을 책임으로 바라보는 것**에서 출발한다.

### 절차

1. **시스템 책임 → 객체 책임으로 할당**
    - 시스템이 맡아야 할 책임을 수행할 적절한 객체를 찾는다.
2. **메시지 도출**
    - 객체가 책임을 완수하기 위해 다른 객체의 도움이 필요하다면,
    - 어떤 **메시지가 필요한지**를 결정한다.
3. **수신자 선택**
    - 결정된 메시지를 수신하기에 적합한 객체를 선택한다.

- 송신자가 메시지를 보낼 때 **기대한 바**를 수신자가 충족해야 한다.
- 즉, **수신자가 메시지를 처리할 책임을 가진다.**

결과적으로 **메시지가 수신자의 책임을 결정한다.**

## What/Who 사이클

책임-주도 설계의 핵심은 

**“무엇을 할 것인가(What)” → “누가 할 것인가(Who)”** 순서로 결정하는 것이다.

이 과정을 **What/Who 사이클**이라고 한다.

### 개념

- **What (무엇)**: 어떤 행위가 필요한가? → **메시지를 먼저 결정한다.**
- **Who (누가)**: 그 행위를 누가 수행할 것인가? → **메시지를 수신할 객체를 선택한다.**

### 절차

1. 협력이라는 문맥에서 필요한 **메시지를 먼저 도출**한다.
2. 해당 메시지를 처리하기에 적합한 **객체를 선택**한다.
3. 메시지를 수신한 객체는 그 메시지를 처리할 **책임을 갖게 된다.**

### 정리

- 협력 설계에서 **메시지가 책임을 결정**한다.
- 책임이 먼저 오고, 객체는 그 책임을 따른다.
- 메시지를 먼저 결정함으로써, 자연스럽게 객체의 **인터페이스**를 발견할 수 있다.

## 묻지말고 시켜라(**Tell, Don’t Ask**)

### 개념

- 객체의 **상태를 직접 묻지 말고**, 필요한 일을 **메시지로 요청**하라.
- “데메테르 법칙(Law of Demeter)”이라고도 불린다.

### 원리

- **메시지를 먼저 결정** → 그 후에 메시지를 처리할 객체를 선택
- 메시지를 정하는 시점에는 수신 객체가 누군지 모른다
    - 따라서 송신자는 **수신자의 내부 상태에 접근할 수 없다**

→ 캡슐화 강화 + 결합도 낮음

### 예시

- 나쁜 예:
    
    ```java
    // 다른 객체의 상태를 묻는 방식
    if (account.getBalance() > 0) { ... }
    ```
    
- 좋은 예:
    
    ```java
    // 그냥 메시지를 시키는 방식
    account.withdraw(100);
    ```
    
- 👉 “어떻게(How)”가 아니라 “무엇(What)”을 요청하라.

### 효과

- **객체 자율성 증가**: 각 객체가 스스로 처리 방법을 결정
- **캡슐화 보장**: 내부 상태가 외부에 노출되지 않음
- **결합도 낮음**: 송신자는 수신자의 내부 구조에 의존하지 않음
- **인터페이스 단순화**: “무엇을 할 수 있는지”만 노출

# 객체 인터페이스

## 인터페이스(Interface)

### 정의

- 두 대상이 만나는 **경계**에서 상호작용을 가능하게 하는 **약속(계약)**
- 객체지향에서는 **객체가 수신할 수 있는 메시지의 목록**이 인터페이스를 결정한다.
- 객체가 책임을 수행하기 위해 외부로부터 **메시지를 받기 위한 통로**

### 특징

- 사용자는 인터페이스만 알면 내부 구조 몰라도 사용 가능
- 내부 구현이 바뀌어도 인터페이스가 같으면 사용자에게 영향 없음
- 같은 인터페이스만 제공하면 다른 객체로 자유롭게 교체 가능

### 예시

```java
// 인터페이스: "짖는다"라는 메시지 정의
interface Animal {
    void speak();
}

// 구현 1
class Dog implements Animal {
    @Override
    public void speak() { // 메서드 구현
        System.out.println("멍멍");
    }
}

// 구현 2
class Cat implements Animal {
    @Override
    public void speak() { // 메서드 구현
        System.out.println("야옹");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.speak(); // 멍멍
        a2.speak(); // 야옹
    }
}

```

## 공용 인터페이스

### 정의

- 객체의 인터페이스는 **외부에서 접근 가능한 것**과 **내부에서만 사용하는 것**으로 나눌 수 있다.
- 그중 **외부에 공개된 인터페이스**를 **공용 인터페이스**라고 한다.

### 특징

1. **공용 인터페이스 = 외부에 공개된 메시지 집합**
    - 다른 객체가 이 객체와 협력하기 위해 사용할 수 있는 **메시지들의 목록**
2. **사적인 인터페이스와 구분**
    - 내부적으로만 쓰이는 인터페이스는 외부에서 접근 불가
    - 하지만 두 경우 모두 **메시지 전송을 통해서만 접근 가능**하다
3. **차이점은 송신자**
    - **공용 인터페이스** → 다른 객체가 메시지를 보냄
    - **사적 인터페이스** → 자기 자신이 내부적으로 메시지를 보냄

### 예시

```java
class Account {
    // 공용 인터페이스 (외부 사용 가능)
    public void deposit(int amount) {
        validate(amount);   // 내부에서만 쓰는 메서드
        System.out.println(amount + "원 입금");
    }

    // 사적 인터페이스 (내부 전용)
    private void validate(int amount) {
        if (amount <= 0) throw new IllegalArgumentException("0원 이하는 불가");
    }
}

public class Main {
    public static void main(String[] args) {
        Account acc = new Account();
        acc.deposit(1000);   // 가능 (공용 인터페이스)

        // acc.validate(1000); // 불가 (사적 인터페이스)
    }
}

```

여기서 “왜 메서드를 인터페이스라고 부르지?” 라고 의문이 생길 수 있다.

- `deposit` `validate` 두 개 다 자바에선 “메서드”지만, **외부와의 약속 측면에서 보면 인터페이스**라고 부를 수 있다.

# 인터페이스와 구현의 분리

## 객체 관점에서 생각하는 방법

맷 와이스펠드(Matt Weisfeld)는 객체지향적인 사고 방식을 이해하기 위해서는 다음 세 가지 원칙이 중요하다고 주장한다.

- 좀 더 추상적인 인터페이스
    - **세부 사항을 제거하고 메시지의 의도를 표현하기 위해 추상화한다.**
- 최소 인터페이스
    - **외부에서 사용할 필요가 없는 인터페이스는 최대한 노출을 하지말라**
        
      → 객체의 내부를 수정하더라도 외부에 미치는 영향을 최소화 가능
        
- 인터페이스와 구현 간에 차이가 있다는 점을 인식
    - 밑에 별도로 설명

## 구현(implementation)

### 정의

- 객체 내부의 구조와 동작 방식을 가리키는 고유한 용어 = **구현**
- **공용 인터페이스에 포함되지 않는 모든 것**이 구현에 속한다.

### 구현에 포함되는 것

1. **상태 (State)**
    - 객체가 가진 데이터
    - 외부에 노출되지 않음
    - 상태를 어떻게 표현할지는 구현에 속한다.
2. **행동 (Behavior)**
    - 메시지를 수신했을 때 실행되는 동작
    - 구체적인 처리 방법 = **메서드의 코드**
    - 메서드의 “코드 내부”는 외부에 보이지 않으므로 구현에 포함된다.

## 인터페이스와 구현의 분리 원칙

### 원칙

- **훌륭한 객체** = 내부 구현을 몰라도, 인터페이스(공용 메시지)만 알면 쉽게 사용할 수 있는 객체
- 설계 시:
    - 외부에 보이는 부분 → **인터페이스**
    - 내부에 숨겨야 하는 부분 → **구현**
- 이 구분을 **인터페이스와 구현의 분리(Separation of Interface and Implementation)**라고 한다.

### 왜 중요한가..?

- **소프트웨어는 항상 변경된다.**
- 인터페이스와 구현을 분리하면:
    - 변경 가능성이 큰 부분은 내부에 숨김 → 외부에 영향 X
    - 외부 협력자는 인터페이스만 의존하므로 안전하게 재사용 가능

이 원칙을 수행하기 위한 객체 설계 방법을 캡슐화라고 한다.

## 캡슐화 (Encapsulation)

객체의 자율성을 보존하기 위해 **구현을 외부로부터 감추는 것**을 **캡슐화**라고 한다.

객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있다.

캡슐화를 **정보 은닉(Information Hiding)**이라고 부르기도 한다.

### 캡슐화의 두 가지 관점

1. **상태와 행위의 캡슐화**
2. **사적인 비밀의 캡슐화**

### 1) 상태와 행위의 캡슐화

- 객체는 상태(state)와 행위(behavior)의 조합이다.
- 상태와 행위를 하나의 단위로 묶어 자율적인 실체로 만드는 것이 캡슐화의 핵심이다.
- 이 관점에서의 캡슐화를 **데이터 캡슐화(Data Encapsulation)**라고 한다.

→ 데이터 캡슐화는 **인터페이스와 구현을 분리**하기 위한 전제 조건이다.

전통적인 방식은 데이터(상태)를 따로, 프로세스(행위)를 따로 두었지만, 객체지향은 이를 **객체라는 하나의 단위**로 묶어 자율성을 보장한다.

→ 이 차이가 전통적 개발 방법과 객체지향을 구분 짓는 핵심이다.

### 2) 사적인 비밀의 캡슐화

- 객체 내부에는 외부에 공개할 필요 없는 **구현**이 존재한다.
- 이런 **내부 구현을 감춤**으로써 외부 객체는 공용 인터페이스(메시지)만 알면 협력할 수 있다.
- 결과적으로 **구현을 숨기면** 내부를 자유롭게 바꿀 수 있고, 외부와의 결합도를 낮출 수 있다.

즉, “객체의 속사정은 감추고, 꼭 필요한 메시지만 공개하라”는 것이 사적인 비밀의 캡슐화다.
