# 5장. 책임과 메시지

---

# 😁 자율적인 책임

객체지향 공동체의 최소 단위는 **자율적인 객체**다. 자율성은 스스로의 원칙과 판단에 따라 행동하는 성질이다. 객체가 움직이는 유일한 이유는 **다른 객체의 요청**을 받았기 때문이며, 그 요청을 처리하기 위해 수행하는 행동을 **책임**이라 부른다. 즉, 자율적인 객체는 **요청을 계기로 자신의 책임을 스스로의 방식으로 수행**한다.

앨리스의 재판 장면을 보면, 왕이 모자 장수에게 ***“증언하라”*** 는 요청(메시지)을 보낸다. 모자 장수는 **증언할 책임**을 지며, *“어떻게 ”* 증언할지(기억을 더듬든, 메모를 읽든)는 **모자 장수의 자율**이다. 왕은 결과만 필요하다. 만약 왕이 `기억을 떠올려라 → 시간순으로 재구성하라 → 간결히 말하라`처럼 세부 절차까지 지시하면, 결과는 같아도 모자 장수의 **선택의 자유**는 훼손된다.

핵심은 간단하다. 포괄적이고 추상적인 책임이 **무조건** 좋은 것은 아니다. 책임은 **협력의 의도를 명확히 설명할 수 있는 수준**에서 추상적이어야 한다. 자율적인 책임의 특징은 객체가 *“어떻게(How)”* 가 아니라 *“무엇(What)”* 을 해야 하는지를 설명한다는 것이다.

> ***책임은 ‘무엇(What)’을 말하고, ‘어떻게(How)’는 수신자의 권한이다.***
>

# 🎏 메시지와 메서드

객체 사이의 상호작용은 오직 **메시지 전송**으로 이뤄진다. 메시지는 두 부분으로 구성된다.

- **메시지 이름**: 무엇을 해 달라는 요구(예: `증언하라`)
- **인자**: 수행에 필요한 추가 정보(예: `어제`, `왕국`)

> ***모자 장수.증언하라(어제, 왕국)***
>

**어떤 메시지를 수신하느냐**가 곧 그 객체의 **책임**과 **공용 인터페이스**의 모양을 결정한다. 외부는 메시지만 본다. 그 메시지를 어떤 방식(메서드)으로 처리할지는 전적으로 **수신자의 자율**이다. 예를 들어 재판에서 모자 장수는 `증인석에_입장하라()`, `증언하라()` 두 메시지를 수신할 수 있어야 한다. 이 두 메시지가 곧 모자 장수가 수행해야 할 책임을 규정한다.

정리하면,

- **메시지** = *“무엇을 해 달라”* 는 **계약**
- **메서드** = 그 계약을 이행하는 **수신자 내부의 절차**

왕은 `증언하라()`라는 메시지만 전송한다. **기억을 더듬을지, 메모를 읽을지** 같은 세부 절차는 모자 장수가 결정한다. 이 경계 덕분에 객체의 외부(공용 인터페이스)와 내부(구현)가 자연스럽게 분리된다.

메시지는 *“무엇”* 만 명시하고 *“어떻게”* 는 강제하지 않기에, **서로 다른 타입의 객체들이 같은 메시지에 각기 다른 메서드로 응답**할 수 있다.

- 모자 장수: 기억을 더듬어 증언
- 요리사: 메모를 읽으며 증언
- 앨리스: 들은 이야기를 바탕으로 증언

왕(송신자) 입장에서는 모두 동일한 책임(증언)을 수행한다. 이것이 **다형성**이며, 곧 역할(증인)에 대한 **행위 호환성**이다. 중요한 건 **송신자 관점**이다. 송신자는 수신자가 누구든 **같은 메시지 계약**만 지키면 된다.

> ***결과적으로 수신자의 종류가 캡슐화된다. 새로운 “증인” 타입을 추가해도 왕의 코드는 바뀌지 않는다.***
>

메시지를 기준으로 협력을 설계하면 얻는 이점:

- **유연성**: 수신자를 다른 타입으로 바꿔도 송신자는 영향 없음
- **확장성**: 협력의 구조는 유지한 채, 수신자만 추가/교체하여 수행 방식을 바꿀 수 있음
- **재사용성**: 동일한 협력(왕 ↔ 증인)을 다양한 문맥·객체 조합에 재사용 가능

객체지향 시스템은 메시지를 주고받는 객체들의 연결망(Web)이다. 시스템의 실제 동작은 **어떤 객체들을 어떻게 연결하느냐**(누가 누구에게 어떤 메시지를 보내는가)에 의해 **창발**한다. 따라서 연결(무엇을 누구에게 시킬지)을 선언적으로 바꾸는 것만으로도 **행위를 쉽게 수정**할 수 있다.

# ✉ 메시지를 따라라

객체지향의 본질은 **책임을 수행하는 자율적 객체들이 협력**해 애플리케이션을 구성하는 데 있다. 이 협력은 **메시지 전송과 수신의 연쇄**로 이루어지며, 시스템이 제공하는 기능은 이 흐름 위에서 드러난다.

클래스는 이 동적 세계를 **정적인 텍스트**로 기술하는 **구현 수단**일 뿐이다. 먼저 할 일은 클래스를 선언하는 것이 아니라 **어떤 객체들이 어떤 메시지를 주고받을지**(행동과 그에 필요한 속성)를 식별하는 일이다.

**메시지 중심 설계(RDD)** 의 절차:

1. **시스템 책임**을 정한다(사용자가 원하는 결과).
2. 그 책임을 이루는 메시지(무엇, What)들을 식별한다.
3. 각 메시지를 **수신할 적합한 객체(누가, Who)** 를 고른다.
4. 수신자는 송신자가 기대한 바를 **처리할 책임**을 진다.
5. 필요하면 수신자가 **새 메시지**를 전송하고, **책임이 완성될 때까지** 반복한다.

이 접근은 객체를 고립시켜 *“이 객체는 이런 속성이 있으니 이런 일을 하겠지”* 라고 추측하지 않는다. **행동을 먼저** 정하고, 그 행동을 수행할 **주체를 나중에** 선택한다.

메시지를 먼저 정하면 자연스럽게 **`묻지 말고 시켜라(Tell, Don’t Ask)`** 스타일이 된다. 송신자는 수신자의 내부 상태를 **묻지 않고**, *“무엇을 해 달라”* 는 **명령적 메시지**만 보낸다. 이는 **데메테르 법칙**과 맞물려 **캡슐화**와 **느슨한 결합**을 강화한다.

- **캡슐화 증진**: 송신자는 수신자의 내부를 볼 이유가 없다.
- **결합도 감소**: 내부를 모르면 바뀌어도 영향이 적다.
- **유연성·확장성**: 새로운 수신자(타입)를 추가해도 메시지 계약만 지키면 협력은 그대로 동작한다.

정리하자면, **객체가 메시지를 고르는 게 아니라, 메시지가 객체를 고른다.** 메시지를 중심으로 협력을 설계하면 **책임이 선행**되고, 그 책임이 객체의 인터페이스를 빚는다. 그 결과 **자율성·캡슐화·느슨한 결합**이 확보되고, 설계는 **유연·확장·재사용** 가능해진다.

# 🖼 객체 인터페이스

**인터페이스**는 두 대상이 만나는 **경계**이자 **사용법**이다. 어떤 대상을 다루려면 그 대상이 제공하는 인터페이스만 알면 된다.

인터페이스의 성질, 세 가지:

- **내부를 몰라도 사용**할 수 있다.
- **내부가 바뀌어도 인터페이스가 같다면** 사용법은 변하지 않는다.
- **대상이 바뀌어도 인터페이스가 같다면** 그대로 대체 가능하다.

자동차를 떠올리자. 운전자는 엔진 구조를 몰라도 **핸들·브레이크·엑셀**만 알면 운전한다. 내부가 바뀌어도 조작법은 같다. 다른 차여도 같은 인터페이스면 운전은 동일하다.

객체가 상호작용하는 **유일한 수단은 메시지 전송**이다. 따라서 객체의 인터페이스는 **수신할 수 있는 메시지의 목록**으로 정의된다.

- **공용 인터페이스**: 외부에서 보낼 수 있는 메시지 집합
- **감춰진 인터페이스(구현)**: 내부 전용 경로/상세

RDD의 **What/Who** 순서를 떠올리자.

1. 무엇(메시지)이 필요한가를 정한다.
2. 그 메시지를 **누가** 수신/처리할지 고른다.

이때 **정해진 메시지**가 수신자의 **책임**을 규정하고, 그 책임이 **공용 인터페이스**의 모양을 결정한다. 외부는 메시지(무엇)만 본다. **어떻게** 처리할지는 수신자의 **메서드**(내부 구현) 선택이다.

> **`메시지 → 책임 → 인터페이스`**
>
>
> ***내부 구현은 인터페이스 뒤로 감춰져 캡슐화와 다형성이 가능해진다.***
>

최종적으로 요약을 하자면,

- 인터페이스 = **수신 가능한 메시지의 목록**
- 메시지가 **책임**을 정하고, 책임이 **인터페이스**를 만든다.
- **어떻게**는 메서드로 감추고(**캡슐화**), **무엇**만 약속한다.
- 같은 인터페이스를 지키는 객체는 **대체 가능**하다.

# ⚖ 인터페이스와 구현의 분리

좋은 인터페이스 설계의 세 원칙:

1. **더 추상적으로**
2. **더 적게(최소 인터페이스)**
3. **인터페이스와 구현을 명확히 구분**


1. 왕은 모자 장수에게 *“기억을 떠올리고 → 시간순으로 재구성하고 → 간결히 말하라(How)”* 가 아니라 **“증언하라(What)”** 만 요청해야 한다. 추상적인 메시지는 수신자의 **자율성**을 보장한다.
2. **최소 인터페이스** 원칙: 외부에서 실제로 **쓸 메시지**만 노출한다. 그러면 내부 정보 노출이 줄고, 내부 변경의 파급효과도 작아진다. RDD와 궁합이 좋다. 협력에 필요한 **필수 메시지**만 인터페이스로 드러내기 때문이다.
3. 인터페이스(무엇)와 구현(어떻게)를 철저히 분리하라.
    - **인터페이스**: 외부에 약속된 **메시지 시그니처**(반환 값/효과 보장)
    - **구현**: 상태 표현과 메서드 코드 같은 **내부 세부사항**

이게 왜 중요할까? **소프트웨어는 항상 변하기** 때문이다.

- **안전 지대**: 내부 구현(마음껏 바꿔도 외부 영향 없음)
- **위험 지대**: 공용 인터페이스(바꾸면 전파됨)

가능한 한 변경은 **안전 지대** 안에서 끝내라. 이를 가능하게 하는 것이 `캡슐화(Encapsulation)`다.

캡슐화는 두 관점에서 이해할 수 있다.

- **데이터 캡슐화**: 상태와 행위를 한 객체 안에 묶고, 외부엔 필요한 행위만 노출
- **비밀의 캡슐화**: 외부는 공용 인터페이스로만 접근, 내부 상태/도우미 메서드는 숨김

그럼 실전에서는 어떻게 해야 할까?

- 외부에 약속할 건 **메시지 시그니처**뿐. 효과를 명확히 하자.
- 상태는 **`private`**, 내부 메서드도 **숨기기**.
- *“이 메시지를 왜 노출해야 하지?”* 필요가 없으면 비공개.
- 테스트는 **인터페이스 기준**으로, 내부 구현 교체에 흔들리지 않게.
- 새로운 요구가 와도 먼저 **메시지(What)** 변경 필요성을 검토하고, 가능하면 **구현(How)** 만 바꿔 흡수하자.

> ***메시지로 약속(인터페이스)하고, 나머지는 전부 감추자(구현).***
>

# 🗽 책임의 자율성이 협력의 품질을 결정

더 좋은 협력은 **이해하기 쉽고**, **변경에 강하다**. 그 출발점은 객체에 **자율적인 책임**을 부여하는 것이다.

- **`의도 중심 → 협력 단순화`**

  : ***“증언하라(What)”*** 만 약속하면 된다. *“기억을 떠올리고…(How)”* 같은 절차는 생략한다. 한 문장의 의도가 세부를 덮어, 협력이 깔끔해진다.

- **`외부/내부 경계 선명화`**

  : 왕은 메시지(인터페이스)만 본다. 모자 장수는 메서드(구현)를 스스로 고른다. 같은 책임만 지키면 내부 방식은 자유다.

- **`변경 내성(Impact 격리)`**

  : 책임이 자율적이면 변경은 객체 **내부**에서 끝난다. 파급효과가 줄고, 객체 간 **결합도**가 낮아진다.

- **`대체 가능성 확보(유연성)`**

  : ***“증언하라”*** 를 이해하는 누구든(모자 장수/요리사/앨리스) **증인 역할**을 맡을 수 있다. 협력은 유지되고 참여자만 바뀐다.

- **`역할 가독성 향상`**

  : ***“증인석에 입장한다 + 증언한다”*** 두 책임만으로도 **증인** 역할이 분명해진다. 책임이 자율적일수록 역할이 선명해진다.


이처럼 자율적인 책임이 가져오는 설계 효과는 아래와 같다.

- **추상화 ↑**: 의도로 말하니 불필요한 디테일이 감춰진다.
- **응집도 ↑ / 결합도 ↓**: 한 책임 안에 관련 행위가 모이고, 외부 의존은 줄어든다.
- **캡슐화 강화**: 내부 구현을 바꿔도 인터페이스는 그대로.
- **인터페이스/구현 분리**: ***“무엇”*** 만 약속하고 ***“어떻게”*** 는 숨긴다.
- **유연성·재사용성 ↑**: 역할만 맞으면 새로운 타입을 그대로 끼워 넣을 수 있다.

> ***“무엇을 할지(책임/메시지)만 약속하고, 어떻게 할지는 객체가 자율적으로 결정하게 하자.”***
>

### <예시 코드>

**What/Who 순서**로 *“무엇을 하게 할지(메시지)”* 를 먼저 정한 뒤, 그 자리를 **대체 가능**한 역할 인터페이스로 묶었다. 한 역할에서 **같은 메시지**를 이해할 수만 있다면 **누구나 그 역할을 수행**할 수 있다. 또한 **외부에서 실제로 사용하는 메시지만 공개**해 **최소 인터페이스 원칙**을 지켰다.

```java
package chapter5;

// 재판을 개시하는 역할
public interface Judge {
    Verdict holdTrial(Summoner summoner, Witness witness, TrialRecord record);
}
```

```java
package chapter5;

// 증인을 소환하는 역할
public interface Summoner {
    // 이제 문맥을 받아 기록까지 책임지도록 한다
    void summon(Witness witness, TrialRecord record);
}
```

```java
package chapter5;

// 재판에 입장하고 증언하는 역할
public interface Witness {
    void enter(TrialRecord record);
    void testify(TrialRecord record);
}
```

`Witness` 설계에서 기존 `enter(): boolean`처럼 결과를 물어 송신자가 분기하던 *Ask* 스타일을 버리고, ***“입장하라/증언하라”*** 는 **명령적 메시지**로 바꿨다(`enter(record)`, `testify(record)`). 성공/실패 처리나 기록 남김 같은 세부는 **수신자의 자율**로 캡슐화한다.

정리하자면…

- **`Tell, Don’t Ask / 데메테르 법칙`**: 내부 상태를 묻지 말고, 필요한 일을 시킨다.
- **`캡슐화`**: 부수효과(기록, 실패 처리)는 수신자 내부로 숨긴다.

```java
package chapter5;

public class Statement {

    private final String text;

    private Statement(String text) {
        this.text = text;
    }

    public static Statement of(String text) {
        return new Statement(text);
    }

    public boolean mentions(String keyword) {
        return text.contains(keyword);
    }

    @Override public String toString() {
        return text;
    }
}
```

```java
package chapter5;

import java.util.ArrayList;
import java.util.List;

public class TrialRecord {

    private final List<Statement> statements = new ArrayList<>();

    public void append(Statement statement) {
        statements.add(statement);
    }

    public int testimonyCount() {
        return statements.size();
    }

    public boolean anyMentions(String keyword) {
        return statements.stream().anyMatch(st -> st.mentions(keyword));
    }

    @Override public String toString() {
        return statements.toString();
    }
}
```

`Statement`와 `TrialRecord`는 **행동이 만든 결과를 담는 상태**다. `Statement.mentions(keyword)`처럼 **데이터 질의를 행동으로 대체**해 `getText()` 의존을 줄였다(“데이터를 묻지 말고, 객체에 시켜라” 원칙…)

판결 규칙은 변동성이 높은 **정책 축**이므로 `VerdictPolicy`로 **분리**했다. 판사는 절차(오케스트레이션)에 집중하고, 평결 룰은 **전략 교체**로 확장한다.

```java
package chapter5;

public interface VerdictPolicy {
    Verdict decide(TrialRecord record);
}
```

```java
package chapter5;

public class SimplePolicy implements VerdictPolicy {

    @Override public Verdict decide(TrialRecord record) {
        return Verdict.of(record.testimonyCount() > 0 ? Type.GUILTY : Type.INNOCENT);
    }
}
```

```java
package chapter5;

public class KeywordPolicy implements VerdictPolicy {

    private final String keyword;

    public KeywordPolicy(String keyword) {
        this.keyword = keyword;
    }

    @Override
    public Verdict decide(TrialRecord record) {
        return Verdict.of(record.anyMentions(keyword) ? Type.GUILTY : Type.INNOCENT);
    }
}
```

*“소환→입장→증언→판단→기록”* 절차는 공통이므로 `BaseJudge`로 따로 뽑아서 중복을 제거하도록 했고, `King`, `Queen`은, **제목·정책만 변경**한다.

```java
package chapter5;

public abstract class BaseJudge implements Judge {

    private final VerdictPolicy verdictPolicy;

    public BaseJudge(VerdictPolicy verdictPolicy) {
        this.verdictPolicy = verdictPolicy;
    }

    @Override
    public Verdict holdTrial(Summoner summoner, Witness witness, TrialRecord record) {
        record.append(Statement.of(title() + "재판을 시작합니다."));
        summoner.summon(witness, record);
        record.append(Statement.of(title() + ": 증언하십시오."));
        witness.testify(record);

        Verdict verdict = verdictPolicy.decide(record);
        record.append(Statement.of(title() + ": 평결 ->" + verdict));

        return verdict;
    }

    // “누가 말하는가”라는 표현만 서브클래스에 위임
    protected abstract String title();
}
```

```java
package chapter5;

public class King extends BaseJudge {

    public King() {
        super(new SimplePolicy());
    }

    @Override
    protected String title() {
        return "왕";
    }
}
```

```java
package chapter5;

public class Queen extends BaseJudge {

    public Queen() {
        super(new KeywordPolicy("steal"));
    }

    @Override
    protected String title() {
        return "여왕";
    }
}
```

나머지 소환자, 증인 구현체도 설계하면…

```java
package chapter5;

public class WhiteRabbit implements Summoner {

    @Override
    public void summon(Witness witness, TrialRecord record) {
        record.append(Statement.of("[WhiteRabbit] 증인을 부릅니다."));
        witness.enter(record);
    }
}
```

```java
package chapter5;

public class Hatter implements Witness {

    private final String feeling;
    public Hatter(String feeling) { this.feeling = feeling; }

    @Override 
    public void enter(TrialRecord record) {
        record.append(Statement.of("모자 장수(" + feeling + "): 증인석에 입장."));
    }

    @Override 
    public void testify(TrialRecord record) {
        String content = switch (feeling) {
            case "nervous" -> "누가 훔친 걸(steal) 봤어요...";
            case "calm"    -> "아무것도 못 봤는데요?";
            default        -> "저 그때 그곳에 없었습니다.";
        };
        
        record.append(Statement.of(content));
    }
}
```

```java
package chapter5;

public class Alice implements Witness {

    @Override
    public void enter(TrialRecord record) {
        record.append(Statement.of("앨리스: 증인석에 입장했습니다."));
    }

    @Override
    public void testify(TrialRecord record) {
        record.append(Statement.of("좀 억울해보이긴 하네요. 근데 진짜 했는지는 모르겠습니다."));
    }
}
```

이제 `main()` 메서드로 결과를 확인해보자.

```java
package chapter5;

public class JudgeMain {
    public static void main(String[] args) {

        Summoner whiteRabbit = new WhiteRabbit();

        // 재판1: 왕과 모자 장수와의 협력
        King king = new King();
        Witness hatter = new Hatter("nervous");
        TrialRecord record1 = new TrialRecord();
        System.out.println("[재판1] 판결=" + king.holdTrial(whiteRabbit, hatter, record1)
                + " | record=" + record1);

        System.out.println();

        // 재판2: 여왕과 앨리스와의 협력
        Queen queen = new Queen();
        Witness alice = new Alice();
        TrialRecord record2 = new TrialRecord();
        System.out.println("[재판2] 판결=" + queen.holdTrial(whiteRabbit, alice, record2)
                + " | record=" + record2);

    }
}

/*

[재판1] 판결=GUILTY | record=[왕: 재판을 시작합니다..., 하얀토끼: 증인을 부릅니다..., 모자 장수(nervous): 증인석에 입장., 왕: 증언하십시오..., 누가 훔친 걸(steal) 봤어요..., 왕: 평결 -> GUILTY]

[재판2] 판결=INNOCENT | record=[여왕: 재판을 시작합니다..., 하얀토끼: 증인을 부릅니다..., 앨리스: 증인석에 입장했습니다., 여왕: 증언하십시오..., 좀 억울해보이긴 하네요. 근데 진짜 했는지는 모르겠습니다., 여왕: 평결 -> INNOCENT]
*/
```