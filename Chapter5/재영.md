# 📘 05 / 책임과 메시지

## 자율적인 책임
- 객체지향 공동체의 기본 단위는 **자율적 객체**다.
- 자율 객체: 스스로의 의지/판단으로 맡은 **책임**을 수행한다.


- **좋은 책임**이 자율적 객체를 만들고, 자율적 객체들이 **유연하고 단순한 협력**을 이룬다.
- 책임은 **충분히 추상적**이되 협력의 의도를 드러낼 만큼 **충분히 구체적**이어야 한다.  
  ⇒ 성급한 일반화를 피하고 **문맥에 가장 적합한 책임**을 선택하라.


- 자율 책임은 **무엇**(**what**)을 설명하며, **어떻게**(**how**)는 감춘다(캡슐화).  
  메시지는 다른 객체에게 자신의 책임을 **수행하게 만드는 유일한 수단**이다.

---

## 메시지와 메서드

### 메시지
- 추가적인 정보는 **인자(argument)** 로 전달한다.
- 메시지는 **메시지 이름 + 인자**의 조합, 메시지 전송은 **수신자 + 메시지**의 조합.  
  → 즉, **수신자, 메시지 이름, 인자**의 순서대로 나열하면 메시지 전송이 됨.
    
  예) `모자장수.증언하라(어제, 왕국)`


- **메시지를 수신할 수 있음 = 그 책임을 수행할 수 있음**을 의미한다.
- 외부는 메시지만 본다. 내부 선택은 보지 못한다(캡슐화).

### 메서드
- 메시지를 처리하기 위해 **내부적으로 선택되는 방법**.
- OOP에서는 메서드가 **클래스 내부 함수/프로시저**로 구현된다.  
  → 메시지를 보내면 **대응 메서드가 실행**된다.
- **실행 시점에 메서드 선택**이 가능 → 절차적 언어와 차별화.

### 다형성
- 서로 다른 타입의 객체가 **같은 메시지**에 **다른 메서드**로 처리 가능하다.
- 송신자 관점에서는 **동일한 책임**을 수행(공유)하므로 수신자를 **구별할 필요가 없다**.  
  → **대체 가능성** 확보, **수신자 종류의 캡슐화**, **유연성/재사용성** 향상.
- 결합도를 **객체 타입**에서 **메시지** 수준으로 묶어 낮춘다.


- **효과**
  1) 협력 변경이 유연해짐(파급효과 축소)
  2) 동작 방식을 확장해도 협력 구조는 유지(협력 수행 방식 확장)
  3) 다양한 문맥에서 협력 재사용 가능

---

## 메시지를 따라라
- 애플리케이션의 중심은 **연쇄적 메시지 교환**에 기반한 **협력 관계**다.
- 클래스가 아니라 **객체와 메시지**가 시스템을 살아 움직이게 한다.


- 협력 관점에서 시스템을 보고, **메시지 흐름**을 먼저 설계하라.
- 데이터 우선 설계는 **자율성 저해/결합도 상승**을 낳는다.  
  협력 속에서 “무엇을 주고받는가(메시지)”를 먼저 결정해야 **좋은 책임**을 얻는다.

> #### ✏️ 흐름 정리(중요도 순)  |  협력 → 메시지 → 책임/역할 → 상태
> - 서비스 설계를 위해선 먼저 객체들의 ‘**협력**’을 구상한다.
> - 협력을 위해선 객체 간에 주고받는 ‘**메시지**’의 흐름으로 구체화된다.
> - 해당 메시지를 수신한 객체는 그에 대한 ‘**책임**’을 수행해야 한다.
> 
>   (추상화 단계 : 역할 → 책임 → 행위)
> - 책임을 수행하기 위해 필요한 정보가 객체의 ‘**상태**’(**데이터**)로 결정된다.

> #### ✏️ 객체지향 서비스 구현의 원리
> - 객체들의 **협력**을 통해 서비스가 구현됨.
> - 협력은, 객체들이 **메시지**를 주고 받으며 자신의 **책임**을 수행하는 것.
>
>   → 책임 수행은 자신의 역할을 다하거나, 다른 객체의 요청에 응답하는 것.

- **책임-주도 설계의 핵심 : 'What/Who 사이클' 과정**
    - **What 먼저**: 필요한 **행위 = 메시지**를 정한다.
    - **Who 다음**: 그 행위를 수행할 **객체/역할(책임)** 을 정한다.
    - 메시지가 **수신자의 책임/인터페이스**를 결정한다.
    - 이 과정을 시스템 책임이 달성될 때까지 반복한다.

⇒ 결과적으로 시스템이 수행해야 하는 **전체 행위**는 협력하는 객체들의 **책임으로 분배**된다.


- **'묻지 말고 시켜라(Tell, Don’t Ask)' / '데메테르 법칙(Law of Demeter)'** :  
  **메시지를 먼저 결정**하고 객체가 **메시지를 따르도록** 하라.  
  → **캡슐화 증진**, **느슨한 결합**, **인터페이스 축소**, **유연성 증가**

---

## 객체 인터페이스
- 인터페이스: 상호작용을 가능하게 하는 **경계/약속**.


- 특징
    1) 사용법만 알면 내부를 몰라도 조작 가능
    2) 인터페이스 고정 시, 내부 교체가 외부에 무영향
    3) 대상이 바뀌어도 **같은 인터페이스**면 무리 없이 교체


- 객체 간 상호작용의 유일한 방법은 **메시지 전송**.  
  → 인터페이스 = **수신 가능한 메시지 목록**.


- **사적 인터페이스**(내부 전용) / **공용 인터페이스**(외부 공개) 모두 **메시지**로만 접근.
  - 자기 자신과의 상호작용 역시 예외가 아님.


- 해당 메시지를 수신할 수 있는 객체를 선정 → 어떤 객체의 공용 인터페이스에 해당 책임이 있으냐
  - “어떤 메시지를 수신할 수 있냐” ⇒ “어떤 책임을 수행할 수 있냐”/ “어떤 인터페이스를 가질 수 있냐” 를 결정한다.

---

## 인터페이스와 구현의 분리
- 객체지향적 사고 방식을 이해하기 위한 세 가지 원칙 :
    1) **좀 더 추상적인 인터페이스**: 지나치게 상세한 수준의 메시지가 아닌 **의도 중심 메시지**로 자율성 보장
    2) **최소 인터페이스**: 필요한 것만 공개, 외부 노출 최소화 ⇒ 외부 영향 최소화
    3) **인터페이스와 구현간에 차이가 있다는 점을 인식**: 외부(공용 인터페이스)와 내부(구현)를 명확히 구분


- **캡슐화(정보 은닉)** 로 달성
    - **데이터 캡슐화**: 상태/행위를 한 단위로 묶고, 외부에는 **필수 행위만** 공개
    - **사적 비밀의 캡슐화**: 구현 세부는 공용 인터페이스 뒤로 감춰 **파급효과 최소화**


- 내부(자율적 변경 가능 비밀) vs 외부(의지/접근 가능한 공용 인터페이스)는 **엄격히 분리**되어야 한다.

---

## 책임의 자율성이 협력의 품질을 결정한다
#### 책임이 자유로워질 경우,
  1) **단순성**: 의도 중심의 추상화로 협력이 이해하기 쉬워진다.
  2) **내/외부 분리**: 인터페이스/구현 분리가 선명해진다(캡슐화).
  3) **변경 안전성**: 내부 변경의 파급이 줄고 **결합도**가 낮아진다.
  4) **유연성/재사용성**: 대체 가능성이 커져 다양한 문맥에 재사용된다.
  5) **응집도↑**: 역할이 분명해져 객체의 존재 이유가 명확해진다.

#### 이를 객체지향 커뮤니티의 전문 용어로,
- **적절한 추상화**
- **응집도↑**, **결합도↓**
- **캡슐화↑**, **인터페이스/구현 분리**
- **유연성/재사용성** 향상

⇒ **결론**: 객체지향의 힘을 끌어내는 출발점은 **책임을 자율적으로 만드는 것**이다.
