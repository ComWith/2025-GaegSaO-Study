# 6장. 객체 지도

---

여행 중 길을 찾는 방법은 보통 두 가지다.

(1) 지나가는 사람에게 **길을 물어** 단계별 지시를 받거나, (2) **지도를 보고** 스스로 경로를 정한다. 목적지는 같아도 과정과 난이도는 크게 다르다.

첫 번째는 **`기능적·해결책 지향(Functional, Solution-directed)`** 접근이다. *“다리 건너 두 번째 골목에서 우회전…”* 처럼 **절차**를 상세히 따라야 한다. 상황이 바뀌면 설명도, 재사용성도 무너진다.

반면 지도는 **`구조적·문제 지향(Structural, Problem-directed)`** 접근이다. 지형이라는 **안정적인 구조**를 추상화해 제공하고, 사용자는 그 구조 위에서 다양한 경로(기능)를 자유롭게 구성한다. 기능 요구는 자주 변하지만 지형(구조)은 잘 변하지 않기 때문에 지도는 **범용적**이고 **재사용 가능**하다.

소프트웨어도 마찬가지다. 전통적 방법은 **변하기 쉬운 기능**에 **구조를 종속**한다(길을 묻기). 객체지향은 **안정적인 구조**에 **변하는 기능**을 얹는다(지도를 보기). 그래서 더 범용적이고, 재사용성이 높고, 변경에 강하다.

# 🆚 기능 설계 vs 구조 설계

훌륭한 설계자는 *“무엇이 바뀔지”* 를 예언하지 않는다. 다만 **언젠가 바뀐다**는 사실을 전제로 **여지를 남겨** 설계한다. 그 최선의 방법은 **자주 변하는 기능**이 아니라 **안정적인 구조**를 중심에 두는 것이다.

객체지향은 **객체의 구조**에 집중하고, 기능이 그 구조를 **따라 흐르도록** 만든다. 시스템 기능은 작은 **책임**으로 쪼개져 적절한 **객체**에 분배되며, 기능이 바뀌어도 **객체 간 구조**는 그대로 유지된다(역할·책임을 식별하고 **메시지**로 협력을 설계하는 이유가 바로 이것).

## 🌮 두 가지 재료: 기능과 구조

객체지향 세계를 만들려면 두 재료가 필요하다.

- **기능**: 사용자가 목표를 달성하기 위해 쓰는 시스템의 서비스.
- **구조**: 기능을 담는 **안정적 토대**(변경을 수용).

이 두 재료를 얻는 대표적 기법은 다음과 같다.

- **도메인 모델링**: 사용자가 도메인을 이해하는 **개념과 관계**(구조)를 모델로 표현한다.
- **유스케이스 모델링**: 사용자의 **목표**를 달성하는 **시스템의 행위**(기능)를 시나리오로 기술한다

## 🍔 안정적인 재료: 구조

- **도메인**: 소프트웨어가 다루는 대상 영역(은행, 게임, 중고차 등).
- **도메인 모델**: 그 영역의 **핵심 개념·관계·규칙**을 의도적으로 단순화·구조화한 모델.
- 도메인 모델은 단순 도표가 아니라, 사용자·설계자·시스템이 **공유하는 멘탈 모델**을 지향한다.

도메인 모델은 단순히 다이어그램이 아니다. 도메인 모델은 이해관계자들이 바라보는 `멘탈 모델(Mental Model)`이다. 멘탈 모델이란 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다.

멘탈 모델은 보통 **사용자 모델**, **디자인 모델**, **시스템 이미지**의 **세 가지**로 설명한다. 객체지향의 강점은 사용자 관점(사용자 모델), 설계자 관점(디자인 모델), 실제 구현(시스템 이미지)이 가깝게 수렴하도록 코드를 구조화할 수 있다는 점이며, 이를 **연결완전성**이라 부른다.

> 소프트웨어 객체는 현실을 그대로 복제하지 않는다. **은유를 통한 재창조**다. 중요한 것은 **사용자가 도메인을 이해하는 방식(도메인 모델)을 잘 투영하는 것**이다. 현실과 소프트웨어의 간극은 **표현적(의미적) 차이**이며, 좋은 은유로 그 간극을 최소화한다.
>

도메인 모델 기반 설계의 효과는 다음과 같다.

- 도메인을 이해하면 **코드도 이해**가 쉽다(구조가 비슷하기 때문).
- 도메인의 본질(잘 안 변하는 것)을 코드 구조에 새겨 **변경 내성**을 얻는다.

## 🍜 불안정한 재료: 기능

**유스케이스**는 사용자가 목표를 이루기 위해 시스템과 주고받는 **상호작용의 흐름**을 텍스트로 기술한 것이다. 시스템의 이해관계자 중 일차 액터(Primary actor)가 목표를 가지고 상호작용을 시작하며, 조건에 따라 여러 **시나리오**로 전개된다. 유스케이스는 이 시나리오들을 **하나의 목표**로 묶는다.

정기예금 도메인으로 예를 들어보자. 정기예금 도메인에서 시스템은 예금주가 정기예금을 중도 해지할 경우 예금주에게 지급할 이자를 계산할 수 있는 기능을 제공해야 한다. 이 유스케이스는 중도 해지 시 지급받을 수 있는 이자액을 알고자 하는 사용자의 목표를 충족시키기 위한 연관된 시나리오의 집합을 표현해야 한다.

유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점이다. 산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다. 이것은 요구사항을 기억하고 관리하는 데 필요한 다양한 정신적 과부화를 줄인다. **사용자 목표가 유스케이스의 핵심이다.** **유스케이스는 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합이다.**

- 유스케이스명: 중도 해지 이자액을 계산한다.
- 일차 액터: 예금주
- 주요 성공 시나리오
    1. 예금주가 정기예금 계좌를 선택한다.
    2. 시스템은 정기예금 계좌 정보를 보여준다.
    3. 예금주가 금일 기준으로 예금을 해지할 경우 지급받을 수 있는 이자 계산을 요청한다.
    4. 시스템은 중도 해지 시 지급받을 수 있는 이자를 계산한 후 결과를 사용자에게 제공한다.
- 확장: 사용자는 해지 일자를 다른 일자로 입력할 수 있다.

유스케이스의 특성에 대해 살펴보자.

1. **유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 텍스트다.** 유스케이스는 다이어그램이 아니다. 중요한 것은 유스케이스 안에 포함돼 있는 상호작용의 흐름이다. 유스케이스의 핵심은 사용자와 시스템 간의 상호작용을 일련의 이야기 흐름으로 표현하는 것이다.


2. **유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.** 예를 들어, 이자 계산 유스케이스는 **2**개의 시나리오를 포함하고 있다. 첫 번째 시나리오는 예금주가 계좌를 선택하고 당일까지의 이자액을 계산하는 것이다. 두 번째 시나리오는 예금주가 계좌를 선택하고 특정 일자까지의 이자액을 계산하는 것이다. 이처럼 유스케이스는 하나의 시나리오가 아니라 이자액 계산이라는 사용자의 목표와 관련된 모든 시나리오의 집합이라는 사실을 알 수 있다. 시나리오를 `유스케이스 인스턴스(Use case Instance)`라고도 한다.


3. **유스케이스는 단순한 피처(Feature) 목록과 다르다.** 피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것이다. 예제 유스케이스에서 피처는 *‘시스템은 정기예금 정보를 보여준다.’* 와 *‘시스템은 당일이나 현재 일자의 이자를 계산한다’* 이다. 피처의 단점은 이 두 피처를 서로 연관이 없는 독립적인 기능으로 보이게끔 만든다는 점이다. 두 피처를 *‘중도 해지 이자액을 계산한다’* 라는 유스케이스로 묶고 사용자와의 상호작용 흐름 속에서 두 피처를 포함하는 이야기를 제공함으로써 시스템의 기능에 대해 의사소통할 수 있는 문맥을 얻을 수 있다.


4. **유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.** 유스케이스는 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춘다. 이처럼 사용자 인터페이스를 배제한 유스케이스 형식을 `본질적인 유스케이스(Essential Use case)`라고 한다.


5. **유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.** 유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것이 아니다. 유스케이스가 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다는 점에 주목해야 한다. 사실 유스케이스는 객체지향과도 상관이 없다. 유스케이스는 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법일 뿐이다.

핵심은 **사용자 목표**다. 목표가 유스케이스를 **결속**시키는 축이다.

# 🧱 기능과 구조를 통합하기

객체지향에서는 시스템을 사용자와 **협력**하는 **거대한 객체**처럼 본다. 유스케이스로부터 시스템의 **첫 메시지**와 **최종 목표**를 확보하고, 도메인 모델로부터 **안정적 구조**를 빌려 **책임을 분배**한다.

흐름을 살펴보자면,

1. 유스케이스에서 **시작 메시지/목표** 파악
2. 도메인 모델의 개념을 은유한 **객체** 선택
3. 협력에 필요한 **메시지**를 식별하며 **책임 할당**
4. 마지막으로 클래스를 만들고 **속성/메서드** 구현

유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다. 도메인 모델은 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다. 책임-주도 설계는 유스케이스로부터 첫 번째 메시지와 사용자가 달성하려는 목표를, 도메인 모델로부터 기능을 수용할 수 있는 안정적인 구조를 제공받아 실제로 동작하는 객체들의 협력 공동체를 창조한다.

여기서 중요한 것은 견고한 객체지향 애플리케이션을 개발하기 위해서는 사용자의 관점에서 시스템의 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 한다는 것이다.

앞서 살펴봤던, 도메인 모델을 기반으로 이자 계산이라는 시스템 책임을 아래와 같이 책임으로 분할하고 객체들에게 할당함으로써 협력하는 객체들의 공동체를 형성할 수 있다.

- **`정기예금`**: 해지 일자를 받아 이자 계산 시작(약정 기간 포함 여부 확인 후 `계좌`에 위임)
- **`계좌`**: 예금액과 해지 일자를 `이자율`로 전달해 이자 생성 위임
- **`이자율`**: 금액·일자를 바탕으로 이자액 계산, **`이자`** 객체 생성/반환

이자 계산에 필요한 객체와 책임이 식별됐으므로 객체를 클래스로, 책임을 클래스의 메서드로 변환함으로써 이자 계산 기능을 구현할 수 있다. 도메인 모델에 명시된 정기예금이나 계좌와 같은 개념을 스스로 상태와 행위를 관리하는 자율적인 객체로 간주한다는 사실에 주목해야 한다.

유스케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 재귀적 합성이라는 객체지향의 기본 개념을 잘 보여준다.

앞에서 설명한 것처럼 도메인 모델을 기반으로 객체 구조를 설계하는 이유는 도메인 모델이 안정적이기 때문이다. 도메인 모델이 안정적인 이유는 도메인 모델을 구성하는 요소가 아래와 같은 특징을 띠기 때문이다.

- 핵심 개념(정기예금/계좌/이자율/이자 등)은 비즈니스가 크게 바뀌지 않는 한 **지속**된다.
- 개념 간 관계는 **비즈니스 규칙**에 뿌리 내려 있어 쉽게 바뀌지 않는다.

도메인 모델의 위와 같은 특징은 도메인 모델을 중심으로 객체 구조를 설계하고 유스케이스의 기능을 객체의 책임으로 분배하는 기본적인 객체지향 설계 방식의 유연함을 잘 보여 준다. 비즈니스 정책이나 규칙이 크게 변경되지 않는 한 시스템의 기능이 변경되더라도 객체 간의 관계는 일정하게 유지된다.

이제 이자를 계산하는 방식이 변할 때 시스템에 어떤 일이 발생하는지 살펴보자.

이제 이자에 대해서도 이자를 지급하는 `복리 이자 방식`을 추가하기로 했다고 해보자. `단리 이자 방식`과 `복리 이자 방식`을 유연하게 선택할 수 있어야 한다.

기존의 단리 이자만을 계산하던 `InterestRate` 클래스를 추상 클래스로 변경하고 단리 이자를 계산하는 `SimpleInterest`와 복리 이자를 계산하는 `CompoundInterest`가 `InterestRate`를 상속받게 한다. `InterestRate`에 정의된 `createInterest()` 메시지를 수신할 경우 객체의 타입에 따라 실행될 메서드가 선택될 수 있게 한다. 즉, 클라이언트는 `createInterest()` **메시지 계약**만 의존하는 것이다. 어떤 구현이 선택되든 구조는 유지된다. 이와 같이 인터페이스를 정의하는 추상 클래스와 인터페이스를 구현하는 구체적인 클래스 간의 상속 관계는 클래스 기반의 객체지향 언어에서 다형성을 구현하는 가장 기본적인 방법이다.

핵심적인 클래스와 클래스 간의 관계는 그대로 유지되고 있다는 것이 중요하다. 이처럼 이자 계산 기능이 변경되거나 추가돼도 대부분의 클래스 구조가 그대로 유지되는 이유는 도메인을 구성하는 기본적인 개념과 관계를 포함하는 도메인 모델을 기반으로 시스템의 기능을 대응시켰기 때문이다.

객체지향의 큰 장점:

- 도메인 모델링과 프로그래밍이 **동일한 패러다임**을 공유한다.
- **모델 → 코드**가 자연스럽고(연결완전성), **코드 → 모델**도 추론 가능(가역성).

결론은 도메인 모델은 문서가 아니라 **공유되는 언어와 개념**, 그리고 그에 **상응하는 코드**다. 모두가 같은 용어로 이야기하고, **코드를 보면 모델이 떠오르게** 만들자. 그것이 **유연하고 이해하기 쉬운** 객체지향 시스템의 토대다.